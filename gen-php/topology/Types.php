<?php
namespace topology;

/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;


final class ComponentType {
  const BOLT = 1;
  const SPOUT = 2;
  static public $__names = array(
    1 => 'BOLT',
    2 => 'SPOUT',
  );
}

final class TopologyInitialStatus {
  const ACTIVE = 1;
  const INACTIVE = 2;
  static public $__names = array(
    1 => 'ACTIVE',
    2 => 'INACTIVE',
  );
}

final class AccessControlType {
  const OTHER = 1;
  const USER = 2;
  static public $__names = array(
    1 => 'OTHER',
    2 => 'USER',
  );
}

final class TopologyStatus {
  const ACTIVE = 1;
  const INACTIVE = 2;
  const REBALANCING = 3;
  const KILLED = 4;
  static public $__names = array(
    1 => 'ACTIVE',
    2 => 'INACTIVE',
    3 => 'REBALANCING',
    4 => 'KILLED',
  );
}

final class NumErrorsChoice {
  const ALL = 0;
  const NONE = 1;
  const ONE = 2;
  static public $__names = array(
    0 => 'ALL',
    1 => 'NONE',
    2 => 'ONE',
  );
}

final class ProfileAction {
  const JPROFILE_STOP = 0;
  const JPROFILE_START = 1;
  const JPROFILE_DUMP = 2;
  const JMAP_DUMP = 3;
  const JSTACK_DUMP = 4;
  const JVM_RESTART = 5;
  static public $__names = array(
    0 => 'JPROFILE_STOP',
    1 => 'JPROFILE_START',
    2 => 'JPROFILE_DUMP',
    3 => 'JMAP_DUMP',
    4 => 'JSTACK_DUMP',
    5 => 'JVM_RESTART',
  );
}

final class LogLevelAction {
  const UNCHANGED = 1;
  const UPDATE = 2;
  const REMOVE = 3;
  static public $__names = array(
    1 => 'UNCHANGED',
    2 => 'UPDATE',
    3 => 'REMOVE',
  );
}

final class DRPCExceptionType {
  const INTERNAL_ERROR = 0;
  const SERVER_SHUTDOWN = 1;
  const SERVER_TIMEOUT = 2;
  const FAILED_REQUEST = 3;
  static public $__names = array(
    0 => 'INTERNAL_ERROR',
    1 => 'SERVER_SHUTDOWN',
    2 => 'SERVER_TIMEOUT',
    3 => 'FAILED_REQUEST',
  );
}

final class HBServerMessageType {
  const CREATE_PATH = 0;
  const CREATE_PATH_RESPONSE = 1;
  const EXISTS = 2;
  const EXISTS_RESPONSE = 3;
  const SEND_PULSE = 4;
  const SEND_PULSE_RESPONSE = 5;
  const GET_ALL_PULSE_FOR_PATH = 6;
  const GET_ALL_PULSE_FOR_PATH_RESPONSE = 7;
  const GET_ALL_NODES_FOR_PATH = 8;
  const GET_ALL_NODES_FOR_PATH_RESPONSE = 9;
  const GET_PULSE = 10;
  const GET_PULSE_RESPONSE = 11;
  const DELETE_PATH = 12;
  const DELETE_PATH_RESPONSE = 13;
  const DELETE_PULSE_ID = 14;
  const DELETE_PULSE_ID_RESPONSE = 15;
  const CONTROL_MESSAGE = 16;
  const SASL_MESSAGE_TOKEN = 17;
  const NOT_AUTHORIZED = 18;
  static public $__names = array(
    0 => 'CREATE_PATH',
    1 => 'CREATE_PATH_RESPONSE',
    2 => 'EXISTS',
    3 => 'EXISTS_RESPONSE',
    4 => 'SEND_PULSE',
    5 => 'SEND_PULSE_RESPONSE',
    6 => 'GET_ALL_PULSE_FOR_PATH',
    7 => 'GET_ALL_PULSE_FOR_PATH_RESPONSE',
    8 => 'GET_ALL_NODES_FOR_PATH',
    9 => 'GET_ALL_NODES_FOR_PATH_RESPONSE',
    10 => 'GET_PULSE',
    11 => 'GET_PULSE_RESPONSE',
    12 => 'DELETE_PATH',
    13 => 'DELETE_PATH_RESPONSE',
    14 => 'DELETE_PULSE_ID',
    15 => 'DELETE_PULSE_ID_RESPONSE',
    16 => 'CONTROL_MESSAGE',
    17 => 'SASL_MESSAGE_TOKEN',
    18 => 'NOT_AUTHORIZED',
  );
}

class JavaObjectArg {
  static $_TSPEC;

  /**
   * @var int
   */
  public $int_arg = null;
  /**
   * @var int
   */
  public $long_arg = null;
  /**
   * @var string
   */
  public $string_arg = null;
  /**
   * @var bool
   */
  public $bool_arg = null;
  /**
   * @var string
   */
  public $binary_arg = null;
  /**
   * @var double
   */
  public $double_arg = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'int_arg',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'long_arg',
          'type' => TType::I64,
          ),
        3 => array(
          'var' => 'string_arg',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'bool_arg',
          'type' => TType::BOOL,
          ),
        5 => array(
          'var' => 'binary_arg',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'double_arg',
          'type' => TType::DOUBLE,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['int_arg'])) {
        $this->int_arg = $vals['int_arg'];
      }
      if (isset($vals['long_arg'])) {
        $this->long_arg = $vals['long_arg'];
      }
      if (isset($vals['string_arg'])) {
        $this->string_arg = $vals['string_arg'];
      }
      if (isset($vals['bool_arg'])) {
        $this->bool_arg = $vals['bool_arg'];
      }
      if (isset($vals['binary_arg'])) {
        $this->binary_arg = $vals['binary_arg'];
      }
      if (isset($vals['double_arg'])) {
        $this->double_arg = $vals['double_arg'];
      }
    }
  }

  public function getName() {
    return 'JavaObjectArg';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->int_arg);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->long_arg);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->string_arg);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->bool_arg);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->binary_arg);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->double_arg);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('JavaObjectArg');
    if ($this->int_arg !== null) {
      $xfer += $output->writeFieldBegin('int_arg', TType::I32, 1);
      $xfer += $output->writeI32($this->int_arg);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->long_arg !== null) {
      $xfer += $output->writeFieldBegin('long_arg', TType::I64, 2);
      $xfer += $output->writeI64($this->long_arg);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->string_arg !== null) {
      $xfer += $output->writeFieldBegin('string_arg', TType::STRING, 3);
      $xfer += $output->writeString($this->string_arg);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->bool_arg !== null) {
      $xfer += $output->writeFieldBegin('bool_arg', TType::BOOL, 4);
      $xfer += $output->writeBool($this->bool_arg);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->binary_arg !== null) {
      $xfer += $output->writeFieldBegin('binary_arg', TType::STRING, 5);
      $xfer += $output->writeString($this->binary_arg);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->double_arg !== null) {
      $xfer += $output->writeFieldBegin('double_arg', TType::DOUBLE, 6);
      $xfer += $output->writeDouble($this->double_arg);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class JavaObject {
  static $_TSPEC;

  /**
   * @var string
   */
  public $full_class_name = null;
  /**
   * @var \topology\JavaObjectArg[]
   */
  public $args_list = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'full_class_name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'args_list',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\topology\JavaObjectArg',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['full_class_name'])) {
        $this->full_class_name = $vals['full_class_name'];
      }
      if (isset($vals['args_list'])) {
        $this->args_list = $vals['args_list'];
      }
    }
  }

  public function getName() {
    return 'JavaObject';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->full_class_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->args_list = array();
            $_size0 = 0;
            $_etype3 = 0;
            $xfer += $input->readListBegin($_etype3, $_size0);
            for ($_i4 = 0; $_i4 < $_size0; ++$_i4)
            {
              $elem5 = null;
              $elem5 = new \topology\JavaObjectArg();
              $xfer += $elem5->read($input);
              $this->args_list []= $elem5;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('JavaObject');
    if ($this->full_class_name !== null) {
      $xfer += $output->writeFieldBegin('full_class_name', TType::STRING, 1);
      $xfer += $output->writeString($this->full_class_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->args_list !== null) {
      if (!is_array($this->args_list)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('args_list', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->args_list));
        {
          foreach ($this->args_list as $iter6)
          {
            $xfer += $iter6->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class NullStruct {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'NullStruct';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('NullStruct');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class GlobalStreamId {
  static $_TSPEC;

  /**
   * @var string
   */
  public $componentId = null;
  /**
   * @var string
   */
  public $streamId = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'componentId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'streamId',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['componentId'])) {
        $this->componentId = $vals['componentId'];
      }
      if (isset($vals['streamId'])) {
        $this->streamId = $vals['streamId'];
      }
    }
  }

  public function getName() {
    return 'GlobalStreamId';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->componentId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->streamId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('GlobalStreamId');
    if ($this->componentId !== null) {
      $xfer += $output->writeFieldBegin('componentId', TType::STRING, 1);
      $xfer += $output->writeString($this->componentId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->streamId !== null) {
      $xfer += $output->writeFieldBegin('streamId', TType::STRING, 2);
      $xfer += $output->writeString($this->streamId);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Grouping {
  static $_TSPEC;

  /**
   * @var string[]
   */
  public $fields = null;
  /**
   * @var \topology\NullStruct
   */
  public $shuffle = null;
  /**
   * @var \topology\NullStruct
   */
  public $all = null;
  /**
   * @var \topology\NullStruct
   */
  public $none = null;
  /**
   * @var \topology\NullStruct
   */
  public $direct = null;
  /**
   * @var \topology\JavaObject
   */
  public $custom_object = null;
  /**
   * @var string
   */
  public $custom_serialized = null;
  /**
   * @var \topology\NullStruct
   */
  public $local_or_shuffle = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'fields',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        2 => array(
          'var' => 'shuffle',
          'type' => TType::STRUCT,
          'class' => '\topology\NullStruct',
          ),
        3 => array(
          'var' => 'all',
          'type' => TType::STRUCT,
          'class' => '\topology\NullStruct',
          ),
        4 => array(
          'var' => 'none',
          'type' => TType::STRUCT,
          'class' => '\topology\NullStruct',
          ),
        5 => array(
          'var' => 'direct',
          'type' => TType::STRUCT,
          'class' => '\topology\NullStruct',
          ),
        6 => array(
          'var' => 'custom_object',
          'type' => TType::STRUCT,
          'class' => '\topology\JavaObject',
          ),
        7 => array(
          'var' => 'custom_serialized',
          'type' => TType::STRING,
          ),
        8 => array(
          'var' => 'local_or_shuffle',
          'type' => TType::STRUCT,
          'class' => '\topology\NullStruct',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['fields'])) {
        $this->fields = $vals['fields'];
      }
      if (isset($vals['shuffle'])) {
        $this->shuffle = $vals['shuffle'];
      }
      if (isset($vals['all'])) {
        $this->all = $vals['all'];
      }
      if (isset($vals['none'])) {
        $this->none = $vals['none'];
      }
      if (isset($vals['direct'])) {
        $this->direct = $vals['direct'];
      }
      if (isset($vals['custom_object'])) {
        $this->custom_object = $vals['custom_object'];
      }
      if (isset($vals['custom_serialized'])) {
        $this->custom_serialized = $vals['custom_serialized'];
      }
      if (isset($vals['local_or_shuffle'])) {
        $this->local_or_shuffle = $vals['local_or_shuffle'];
      }
    }
  }

  public function getName() {
    return 'Grouping';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->fields = array();
            $_size7 = 0;
            $_etype10 = 0;
            $xfer += $input->readListBegin($_etype10, $_size7);
            for ($_i11 = 0; $_i11 < $_size7; ++$_i11)
            {
              $elem12 = null;
              $xfer += $input->readString($elem12);
              $this->fields []= $elem12;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->shuffle = new \topology\NullStruct();
            $xfer += $this->shuffle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->all = new \topology\NullStruct();
            $xfer += $this->all->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->none = new \topology\NullStruct();
            $xfer += $this->none->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRUCT) {
            $this->direct = new \topology\NullStruct();
            $xfer += $this->direct->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRUCT) {
            $this->custom_object = new \topology\JavaObject();
            $xfer += $this->custom_object->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->custom_serialized);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::STRUCT) {
            $this->local_or_shuffle = new \topology\NullStruct();
            $xfer += $this->local_or_shuffle->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Grouping');
    if ($this->fields !== null) {
      if (!is_array($this->fields)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('fields', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRING, count($this->fields));
        {
          foreach ($this->fields as $iter13)
          {
            $xfer += $output->writeString($iter13);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->shuffle !== null) {
      if (!is_object($this->shuffle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('shuffle', TType::STRUCT, 2);
      $xfer += $this->shuffle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->all !== null) {
      if (!is_object($this->all)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('all', TType::STRUCT, 3);
      $xfer += $this->all->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->none !== null) {
      if (!is_object($this->none)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('none', TType::STRUCT, 4);
      $xfer += $this->none->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->direct !== null) {
      if (!is_object($this->direct)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('direct', TType::STRUCT, 5);
      $xfer += $this->direct->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->custom_object !== null) {
      if (!is_object($this->custom_object)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('custom_object', TType::STRUCT, 6);
      $xfer += $this->custom_object->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->custom_serialized !== null) {
      $xfer += $output->writeFieldBegin('custom_serialized', TType::STRING, 7);
      $xfer += $output->writeString($this->custom_serialized);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->local_or_shuffle !== null) {
      if (!is_object($this->local_or_shuffle)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('local_or_shuffle', TType::STRUCT, 8);
      $xfer += $this->local_or_shuffle->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class StreamInfo {
  static $_TSPEC;

  /**
   * @var string[]
   */
  public $output_fields = null;
  /**
   * @var bool
   */
  public $direct = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'output_fields',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        2 => array(
          'var' => 'direct',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['output_fields'])) {
        $this->output_fields = $vals['output_fields'];
      }
      if (isset($vals['direct'])) {
        $this->direct = $vals['direct'];
      }
    }
  }

  public function getName() {
    return 'StreamInfo';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->output_fields = array();
            $_size14 = 0;
            $_etype17 = 0;
            $xfer += $input->readListBegin($_etype17, $_size14);
            for ($_i18 = 0; $_i18 < $_size14; ++$_i18)
            {
              $elem19 = null;
              $xfer += $input->readString($elem19);
              $this->output_fields []= $elem19;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->direct);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('StreamInfo');
    if ($this->output_fields !== null) {
      if (!is_array($this->output_fields)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('output_fields', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRING, count($this->output_fields));
        {
          foreach ($this->output_fields as $iter20)
          {
            $xfer += $output->writeString($iter20);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->direct !== null) {
      $xfer += $output->writeFieldBegin('direct', TType::BOOL, 2);
      $xfer += $output->writeBool($this->direct);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ShellComponent {
  static $_TSPEC;

  /**
   * @var string
   */
  public $execution_command = null;
  /**
   * @var string
   */
  public $script = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'execution_command',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'script',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['execution_command'])) {
        $this->execution_command = $vals['execution_command'];
      }
      if (isset($vals['script'])) {
        $this->script = $vals['script'];
      }
    }
  }

  public function getName() {
    return 'ShellComponent';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->execution_command);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->script);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ShellComponent');
    if ($this->execution_command !== null) {
      $xfer += $output->writeFieldBegin('execution_command', TType::STRING, 1);
      $xfer += $output->writeString($this->execution_command);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->script !== null) {
      $xfer += $output->writeFieldBegin('script', TType::STRING, 2);
      $xfer += $output->writeString($this->script);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ComponentObject {
  static $_TSPEC;

  /**
   * @var string
   */
  public $serialized_java = null;
  /**
   * @var \topology\ShellComponent
   */
  public $shell = null;
  /**
   * @var \topology\JavaObject
   */
  public $java_object = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'serialized_java',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'shell',
          'type' => TType::STRUCT,
          'class' => '\topology\ShellComponent',
          ),
        3 => array(
          'var' => 'java_object',
          'type' => TType::STRUCT,
          'class' => '\topology\JavaObject',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['serialized_java'])) {
        $this->serialized_java = $vals['serialized_java'];
      }
      if (isset($vals['shell'])) {
        $this->shell = $vals['shell'];
      }
      if (isset($vals['java_object'])) {
        $this->java_object = $vals['java_object'];
      }
    }
  }

  public function getName() {
    return 'ComponentObject';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->serialized_java);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->shell = new \topology\ShellComponent();
            $xfer += $this->shell->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->java_object = new \topology\JavaObject();
            $xfer += $this->java_object->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ComponentObject');
    if ($this->serialized_java !== null) {
      $xfer += $output->writeFieldBegin('serialized_java', TType::STRING, 1);
      $xfer += $output->writeString($this->serialized_java);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->shell !== null) {
      if (!is_object($this->shell)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('shell', TType::STRUCT, 2);
      $xfer += $this->shell->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->java_object !== null) {
      if (!is_object($this->java_object)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('java_object', TType::STRUCT, 3);
      $xfer += $this->java_object->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ComponentCommon {
  static $_TSPEC;

  /**
   * @var array
   */
  public $inputs = null;
  /**
   * @var array
   */
  public $streams = null;
  /**
   * @var int
   */
  public $parallelism_hint = null;
  /**
   * @var string
   */
  public $json_conf = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'inputs',
          'type' => TType::MAP,
          'ktype' => TType::STRUCT,
          'vtype' => TType::STRUCT,
          'key' => array(
            'type' => TType::STRUCT,
            'class' => '\topology\GlobalStreamId',
          ),
          'val' => array(
            'type' => TType::STRUCT,
            'class' => '\topology\Grouping',
            ),
          ),
        2 => array(
          'var' => 'streams',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRUCT,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRUCT,
            'class' => '\topology\StreamInfo',
            ),
          ),
        3 => array(
          'var' => 'parallelism_hint',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'json_conf',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['inputs'])) {
        $this->inputs = $vals['inputs'];
      }
      if (isset($vals['streams'])) {
        $this->streams = $vals['streams'];
      }
      if (isset($vals['parallelism_hint'])) {
        $this->parallelism_hint = $vals['parallelism_hint'];
      }
      if (isset($vals['json_conf'])) {
        $this->json_conf = $vals['json_conf'];
      }
    }
  }

  public function getName() {
    return 'ComponentCommon';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->inputs = array();
            $_size21 = 0;
            $_ktype22 = 0;
            $_vtype23 = 0;
            $xfer += $input->readMapBegin($_ktype22, $_vtype23, $_size21);
            for ($_i25 = 0; $_i25 < $_size21; ++$_i25)
            {
              $key26 = new \topology\GlobalStreamId();
              $val27 = new \topology\Grouping();
              $key26 = new \topology\GlobalStreamId();
              $xfer += $key26->read($input);
              $val27 = new \topology\Grouping();
              $xfer += $val27->read($input);
              $this->inputs[$key26] = $val27;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::MAP) {
            $this->streams = array();
            $_size28 = 0;
            $_ktype29 = 0;
            $_vtype30 = 0;
            $xfer += $input->readMapBegin($_ktype29, $_vtype30, $_size28);
            for ($_i32 = 0; $_i32 < $_size28; ++$_i32)
            {
              $key33 = '';
              $val34 = new \topology\StreamInfo();
              $xfer += $input->readString($key33);
              $val34 = new \topology\StreamInfo();
              $xfer += $val34->read($input);
              $this->streams[$key33] = $val34;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->parallelism_hint);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->json_conf);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ComponentCommon');
    if ($this->inputs !== null) {
      if (!is_array($this->inputs)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('inputs', TType::MAP, 1);
      {
        $output->writeMapBegin(TType::STRUCT, TType::STRUCT, count($this->inputs));
        {
          foreach ($this->inputs as $kiter35 => $viter36)
          {
            $xfer += $kiter35->write($output);
            $xfer += $viter36->write($output);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->streams !== null) {
      if (!is_array($this->streams)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('streams', TType::MAP, 2);
      {
        $output->writeMapBegin(TType::STRING, TType::STRUCT, count($this->streams));
        {
          foreach ($this->streams as $kiter37 => $viter38)
          {
            $xfer += $output->writeString($kiter37);
            $xfer += $viter38->write($output);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->parallelism_hint !== null) {
      $xfer += $output->writeFieldBegin('parallelism_hint', TType::I32, 3);
      $xfer += $output->writeI32($this->parallelism_hint);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->json_conf !== null) {
      $xfer += $output->writeFieldBegin('json_conf', TType::STRING, 4);
      $xfer += $output->writeString($this->json_conf);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SpoutSpec {
  static $_TSPEC;

  /**
   * @var \topology\ComponentObject
   */
  public $spout_object = null;
  /**
   * @var \topology\ComponentCommon
   */
  public $common = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'spout_object',
          'type' => TType::STRUCT,
          'class' => '\topology\ComponentObject',
          ),
        2 => array(
          'var' => 'common',
          'type' => TType::STRUCT,
          'class' => '\topology\ComponentCommon',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['spout_object'])) {
        $this->spout_object = $vals['spout_object'];
      }
      if (isset($vals['common'])) {
        $this->common = $vals['common'];
      }
    }
  }

  public function getName() {
    return 'SpoutSpec';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->spout_object = new \topology\ComponentObject();
            $xfer += $this->spout_object->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->common = new \topology\ComponentCommon();
            $xfer += $this->common->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SpoutSpec');
    if ($this->spout_object !== null) {
      if (!is_object($this->spout_object)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('spout_object', TType::STRUCT, 1);
      $xfer += $this->spout_object->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->common !== null) {
      if (!is_object($this->common)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('common', TType::STRUCT, 2);
      $xfer += $this->common->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Bolt {
  static $_TSPEC;

  /**
   * @var \topology\ComponentObject
   */
  public $bolt_object = null;
  /**
   * @var \topology\ComponentCommon
   */
  public $common = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'bolt_object',
          'type' => TType::STRUCT,
          'class' => '\topology\ComponentObject',
          ),
        2 => array(
          'var' => 'common',
          'type' => TType::STRUCT,
          'class' => '\topology\ComponentCommon',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['bolt_object'])) {
        $this->bolt_object = $vals['bolt_object'];
      }
      if (isset($vals['common'])) {
        $this->common = $vals['common'];
      }
    }
  }

  public function getName() {
    return 'Bolt';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->bolt_object = new \topology\ComponentObject();
            $xfer += $this->bolt_object->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->common = new \topology\ComponentCommon();
            $xfer += $this->common->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Bolt');
    if ($this->bolt_object !== null) {
      if (!is_object($this->bolt_object)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('bolt_object', TType::STRUCT, 1);
      $xfer += $this->bolt_object->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->common !== null) {
      if (!is_object($this->common)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('common', TType::STRUCT, 2);
      $xfer += $this->common->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class StateSpoutSpec {
  static $_TSPEC;

  /**
   * @var \topology\ComponentObject
   */
  public $state_spout_object = null;
  /**
   * @var \topology\ComponentCommon
   */
  public $common = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'state_spout_object',
          'type' => TType::STRUCT,
          'class' => '\topology\ComponentObject',
          ),
        2 => array(
          'var' => 'common',
          'type' => TType::STRUCT,
          'class' => '\topology\ComponentCommon',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['state_spout_object'])) {
        $this->state_spout_object = $vals['state_spout_object'];
      }
      if (isset($vals['common'])) {
        $this->common = $vals['common'];
      }
    }
  }

  public function getName() {
    return 'StateSpoutSpec';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->state_spout_object = new \topology\ComponentObject();
            $xfer += $this->state_spout_object->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->common = new \topology\ComponentCommon();
            $xfer += $this->common->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('StateSpoutSpec');
    if ($this->state_spout_object !== null) {
      if (!is_object($this->state_spout_object)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('state_spout_object', TType::STRUCT, 1);
      $xfer += $this->state_spout_object->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->common !== null) {
      if (!is_object($this->common)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('common', TType::STRUCT, 2);
      $xfer += $this->common->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class StormTopology {
  static $_TSPEC;

  /**
   * @var array
   */
  public $spouts = null;
  /**
   * @var array
   */
  public $bolts = null;
  /**
   * @var array
   */
  public $state_spouts = null;
  /**
   * @var string[]
   */
  public $worker_hooks = null;
  /**
   * @var string[]
   */
  public $dependency_jars = null;
  /**
   * @var string[]
   */
  public $dependency_artifacts = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'spouts',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRUCT,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRUCT,
            'class' => '\topology\SpoutSpec',
            ),
          ),
        2 => array(
          'var' => 'bolts',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRUCT,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRUCT,
            'class' => '\topology\Bolt',
            ),
          ),
        3 => array(
          'var' => 'state_spouts',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRUCT,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRUCT,
            'class' => '\topology\StateSpoutSpec',
            ),
          ),
        4 => array(
          'var' => 'worker_hooks',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        5 => array(
          'var' => 'dependency_jars',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        6 => array(
          'var' => 'dependency_artifacts',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['spouts'])) {
        $this->spouts = $vals['spouts'];
      }
      if (isset($vals['bolts'])) {
        $this->bolts = $vals['bolts'];
      }
      if (isset($vals['state_spouts'])) {
        $this->state_spouts = $vals['state_spouts'];
      }
      if (isset($vals['worker_hooks'])) {
        $this->worker_hooks = $vals['worker_hooks'];
      }
      if (isset($vals['dependency_jars'])) {
        $this->dependency_jars = $vals['dependency_jars'];
      }
      if (isset($vals['dependency_artifacts'])) {
        $this->dependency_artifacts = $vals['dependency_artifacts'];
      }
    }
  }

  public function getName() {
    return 'StormTopology';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->spouts = array();
            $_size39 = 0;
            $_ktype40 = 0;
            $_vtype41 = 0;
            $xfer += $input->readMapBegin($_ktype40, $_vtype41, $_size39);
            for ($_i43 = 0; $_i43 < $_size39; ++$_i43)
            {
              $key44 = '';
              $val45 = new \topology\SpoutSpec();
              $xfer += $input->readString($key44);
              $val45 = new \topology\SpoutSpec();
              $xfer += $val45->read($input);
              $this->spouts[$key44] = $val45;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::MAP) {
            $this->bolts = array();
            $_size46 = 0;
            $_ktype47 = 0;
            $_vtype48 = 0;
            $xfer += $input->readMapBegin($_ktype47, $_vtype48, $_size46);
            for ($_i50 = 0; $_i50 < $_size46; ++$_i50)
            {
              $key51 = '';
              $val52 = new \topology\Bolt();
              $xfer += $input->readString($key51);
              $val52 = new \topology\Bolt();
              $xfer += $val52->read($input);
              $this->bolts[$key51] = $val52;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::MAP) {
            $this->state_spouts = array();
            $_size53 = 0;
            $_ktype54 = 0;
            $_vtype55 = 0;
            $xfer += $input->readMapBegin($_ktype54, $_vtype55, $_size53);
            for ($_i57 = 0; $_i57 < $_size53; ++$_i57)
            {
              $key58 = '';
              $val59 = new \topology\StateSpoutSpec();
              $xfer += $input->readString($key58);
              $val59 = new \topology\StateSpoutSpec();
              $xfer += $val59->read($input);
              $this->state_spouts[$key58] = $val59;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::LST) {
            $this->worker_hooks = array();
            $_size60 = 0;
            $_etype63 = 0;
            $xfer += $input->readListBegin($_etype63, $_size60);
            for ($_i64 = 0; $_i64 < $_size60; ++$_i64)
            {
              $elem65 = null;
              $xfer += $input->readString($elem65);
              $this->worker_hooks []= $elem65;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::LST) {
            $this->dependency_jars = array();
            $_size66 = 0;
            $_etype69 = 0;
            $xfer += $input->readListBegin($_etype69, $_size66);
            for ($_i70 = 0; $_i70 < $_size66; ++$_i70)
            {
              $elem71 = null;
              $xfer += $input->readString($elem71);
              $this->dependency_jars []= $elem71;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::LST) {
            $this->dependency_artifacts = array();
            $_size72 = 0;
            $_etype75 = 0;
            $xfer += $input->readListBegin($_etype75, $_size72);
            for ($_i76 = 0; $_i76 < $_size72; ++$_i76)
            {
              $elem77 = null;
              $xfer += $input->readString($elem77);
              $this->dependency_artifacts []= $elem77;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('StormTopology');
    if ($this->spouts !== null) {
      if (!is_array($this->spouts)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('spouts', TType::MAP, 1);
      {
        $output->writeMapBegin(TType::STRING, TType::STRUCT, count($this->spouts));
        {
          foreach ($this->spouts as $kiter78 => $viter79)
          {
            $xfer += $output->writeString($kiter78);
            $xfer += $viter79->write($output);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->bolts !== null) {
      if (!is_array($this->bolts)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('bolts', TType::MAP, 2);
      {
        $output->writeMapBegin(TType::STRING, TType::STRUCT, count($this->bolts));
        {
          foreach ($this->bolts as $kiter80 => $viter81)
          {
            $xfer += $output->writeString($kiter80);
            $xfer += $viter81->write($output);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->state_spouts !== null) {
      if (!is_array($this->state_spouts)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('state_spouts', TType::MAP, 3);
      {
        $output->writeMapBegin(TType::STRING, TType::STRUCT, count($this->state_spouts));
        {
          foreach ($this->state_spouts as $kiter82 => $viter83)
          {
            $xfer += $output->writeString($kiter82);
            $xfer += $viter83->write($output);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->worker_hooks !== null) {
      if (!is_array($this->worker_hooks)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('worker_hooks', TType::LST, 4);
      {
        $output->writeListBegin(TType::STRING, count($this->worker_hooks));
        {
          foreach ($this->worker_hooks as $iter84)
          {
            $xfer += $output->writeString($iter84);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dependency_jars !== null) {
      if (!is_array($this->dependency_jars)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('dependency_jars', TType::LST, 5);
      {
        $output->writeListBegin(TType::STRING, count($this->dependency_jars));
        {
          foreach ($this->dependency_jars as $iter85)
          {
            $xfer += $output->writeString($iter85);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dependency_artifacts !== null) {
      if (!is_array($this->dependency_artifacts)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('dependency_artifacts', TType::LST, 6);
      {
        $output->writeListBegin(TType::STRING, count($this->dependency_artifacts));
        {
          foreach ($this->dependency_artifacts as $iter86)
          {
            $xfer += $output->writeString($iter86);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class AlreadyAliveException extends TException {
  static $_TSPEC;

  /**
   * @var string
   */
  public $msg = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'msg',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['msg'])) {
        $this->msg = $vals['msg'];
      }
    }
  }

  public function getName() {
    return 'AlreadyAliveException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->msg);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('AlreadyAliveException');
    if ($this->msg !== null) {
      $xfer += $output->writeFieldBegin('msg', TType::STRING, 1);
      $xfer += $output->writeString($this->msg);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class NotAliveException extends TException {
  static $_TSPEC;

  /**
   * @var string
   */
  public $msg = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'msg',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['msg'])) {
        $this->msg = $vals['msg'];
      }
    }
  }

  public function getName() {
    return 'NotAliveException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->msg);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('NotAliveException');
    if ($this->msg !== null) {
      $xfer += $output->writeFieldBegin('msg', TType::STRING, 1);
      $xfer += $output->writeString($this->msg);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class AuthorizationException extends TException {
  static $_TSPEC;

  /**
   * @var string
   */
  public $msg = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'msg',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['msg'])) {
        $this->msg = $vals['msg'];
      }
    }
  }

  public function getName() {
    return 'AuthorizationException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->msg);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('AuthorizationException');
    if ($this->msg !== null) {
      $xfer += $output->writeFieldBegin('msg', TType::STRING, 1);
      $xfer += $output->writeString($this->msg);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class InvalidTopologyException extends TException {
  static $_TSPEC;

  /**
   * @var string
   */
  public $msg = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'msg',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['msg'])) {
        $this->msg = $vals['msg'];
      }
    }
  }

  public function getName() {
    return 'InvalidTopologyException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->msg);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('InvalidTopologyException');
    if ($this->msg !== null) {
      $xfer += $output->writeFieldBegin('msg', TType::STRING, 1);
      $xfer += $output->writeString($this->msg);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class KeyNotFoundException extends TException {
  static $_TSPEC;

  /**
   * @var string
   */
  public $msg = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'msg',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['msg'])) {
        $this->msg = $vals['msg'];
      }
    }
  }

  public function getName() {
    return 'KeyNotFoundException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->msg);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('KeyNotFoundException');
    if ($this->msg !== null) {
      $xfer += $output->writeFieldBegin('msg', TType::STRING, 1);
      $xfer += $output->writeString($this->msg);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class KeyAlreadyExistsException extends TException {
  static $_TSPEC;

  /**
   * @var string
   */
  public $msg = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'msg',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['msg'])) {
        $this->msg = $vals['msg'];
      }
    }
  }

  public function getName() {
    return 'KeyAlreadyExistsException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->msg);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('KeyAlreadyExistsException');
    if ($this->msg !== null) {
      $xfer += $output->writeFieldBegin('msg', TType::STRING, 1);
      $xfer += $output->writeString($this->msg);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TopologySummary {
  static $_TSPEC;

  /**
   * @var string
   */
  public $id = null;
  /**
   * @var string
   */
  public $name = null;
  /**
   * @var int
   */
  public $num_tasks = null;
  /**
   * @var int
   */
  public $num_executors = null;
  /**
   * @var int
   */
  public $num_workers = null;
  /**
   * @var int
   */
  public $uptime_secs = null;
  /**
   * @var string
   */
  public $status = null;
  /**
   * @var string
   */
  public $sched_status = null;
  /**
   * @var string
   */
  public $owner = null;
  /**
   * @var int
   */
  public $replication_count = null;
  /**
   * @var double
   */
  public $requested_memonheap = null;
  /**
   * @var double
   */
  public $requested_memoffheap = null;
  /**
   * @var double
   */
  public $requested_cpu = null;
  /**
   * @var double
   */
  public $assigned_memonheap = null;
  /**
   * @var double
   */
  public $assigned_memoffheap = null;
  /**
   * @var double
   */
  public $assigned_cpu = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'id',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'num_tasks',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'num_executors',
          'type' => TType::I32,
          ),
        5 => array(
          'var' => 'num_workers',
          'type' => TType::I32,
          ),
        6 => array(
          'var' => 'uptime_secs',
          'type' => TType::I32,
          ),
        7 => array(
          'var' => 'status',
          'type' => TType::STRING,
          ),
        513 => array(
          'var' => 'sched_status',
          'type' => TType::STRING,
          ),
        514 => array(
          'var' => 'owner',
          'type' => TType::STRING,
          ),
        515 => array(
          'var' => 'replication_count',
          'type' => TType::I32,
          ),
        521 => array(
          'var' => 'requested_memonheap',
          'type' => TType::DOUBLE,
          ),
        522 => array(
          'var' => 'requested_memoffheap',
          'type' => TType::DOUBLE,
          ),
        523 => array(
          'var' => 'requested_cpu',
          'type' => TType::DOUBLE,
          ),
        524 => array(
          'var' => 'assigned_memonheap',
          'type' => TType::DOUBLE,
          ),
        525 => array(
          'var' => 'assigned_memoffheap',
          'type' => TType::DOUBLE,
          ),
        526 => array(
          'var' => 'assigned_cpu',
          'type' => TType::DOUBLE,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['id'])) {
        $this->id = $vals['id'];
      }
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['num_tasks'])) {
        $this->num_tasks = $vals['num_tasks'];
      }
      if (isset($vals['num_executors'])) {
        $this->num_executors = $vals['num_executors'];
      }
      if (isset($vals['num_workers'])) {
        $this->num_workers = $vals['num_workers'];
      }
      if (isset($vals['uptime_secs'])) {
        $this->uptime_secs = $vals['uptime_secs'];
      }
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
      if (isset($vals['sched_status'])) {
        $this->sched_status = $vals['sched_status'];
      }
      if (isset($vals['owner'])) {
        $this->owner = $vals['owner'];
      }
      if (isset($vals['replication_count'])) {
        $this->replication_count = $vals['replication_count'];
      }
      if (isset($vals['requested_memonheap'])) {
        $this->requested_memonheap = $vals['requested_memonheap'];
      }
      if (isset($vals['requested_memoffheap'])) {
        $this->requested_memoffheap = $vals['requested_memoffheap'];
      }
      if (isset($vals['requested_cpu'])) {
        $this->requested_cpu = $vals['requested_cpu'];
      }
      if (isset($vals['assigned_memonheap'])) {
        $this->assigned_memonheap = $vals['assigned_memonheap'];
      }
      if (isset($vals['assigned_memoffheap'])) {
        $this->assigned_memoffheap = $vals['assigned_memoffheap'];
      }
      if (isset($vals['assigned_cpu'])) {
        $this->assigned_cpu = $vals['assigned_cpu'];
      }
    }
  }

  public function getName() {
    return 'TopologySummary';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->num_tasks);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->num_executors);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->num_workers);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->uptime_secs);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->status);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 513:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->sched_status);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 514:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->owner);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 515:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->replication_count);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 521:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->requested_memonheap);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 522:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->requested_memoffheap);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 523:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->requested_cpu);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 524:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->assigned_memonheap);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 525:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->assigned_memoffheap);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 526:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->assigned_cpu);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TopologySummary');
    if ($this->id !== null) {
      $xfer += $output->writeFieldBegin('id', TType::STRING, 1);
      $xfer += $output->writeString($this->id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 2);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->num_tasks !== null) {
      $xfer += $output->writeFieldBegin('num_tasks', TType::I32, 3);
      $xfer += $output->writeI32($this->num_tasks);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->num_executors !== null) {
      $xfer += $output->writeFieldBegin('num_executors', TType::I32, 4);
      $xfer += $output->writeI32($this->num_executors);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->num_workers !== null) {
      $xfer += $output->writeFieldBegin('num_workers', TType::I32, 5);
      $xfer += $output->writeI32($this->num_workers);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->uptime_secs !== null) {
      $xfer += $output->writeFieldBegin('uptime_secs', TType::I32, 6);
      $xfer += $output->writeI32($this->uptime_secs);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->status !== null) {
      $xfer += $output->writeFieldBegin('status', TType::STRING, 7);
      $xfer += $output->writeString($this->status);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->sched_status !== null) {
      $xfer += $output->writeFieldBegin('sched_status', TType::STRING, 513);
      $xfer += $output->writeString($this->sched_status);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->owner !== null) {
      $xfer += $output->writeFieldBegin('owner', TType::STRING, 514);
      $xfer += $output->writeString($this->owner);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->replication_count !== null) {
      $xfer += $output->writeFieldBegin('replication_count', TType::I32, 515);
      $xfer += $output->writeI32($this->replication_count);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->requested_memonheap !== null) {
      $xfer += $output->writeFieldBegin('requested_memonheap', TType::DOUBLE, 521);
      $xfer += $output->writeDouble($this->requested_memonheap);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->requested_memoffheap !== null) {
      $xfer += $output->writeFieldBegin('requested_memoffheap', TType::DOUBLE, 522);
      $xfer += $output->writeDouble($this->requested_memoffheap);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->requested_cpu !== null) {
      $xfer += $output->writeFieldBegin('requested_cpu', TType::DOUBLE, 523);
      $xfer += $output->writeDouble($this->requested_cpu);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->assigned_memonheap !== null) {
      $xfer += $output->writeFieldBegin('assigned_memonheap', TType::DOUBLE, 524);
      $xfer += $output->writeDouble($this->assigned_memonheap);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->assigned_memoffheap !== null) {
      $xfer += $output->writeFieldBegin('assigned_memoffheap', TType::DOUBLE, 525);
      $xfer += $output->writeDouble($this->assigned_memoffheap);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->assigned_cpu !== null) {
      $xfer += $output->writeFieldBegin('assigned_cpu', TType::DOUBLE, 526);
      $xfer += $output->writeDouble($this->assigned_cpu);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SupervisorSummary {
  static $_TSPEC;

  /**
   * @var string
   */
  public $host = null;
  /**
   * @var int
   */
  public $uptime_secs = null;
  /**
   * @var int
   */
  public $num_workers = null;
  /**
   * @var int
   */
  public $num_used_workers = null;
  /**
   * @var string
   */
  public $supervisor_id = null;
  /**
   * @var string
   */
  public $version = "VERSION_NOT_PROVIDED";
  /**
   * @var array
   */
  public $total_resources = null;
  /**
   * @var double
   */
  public $used_mem = null;
  /**
   * @var double
   */
  public $used_cpu = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'host',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'uptime_secs',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'num_workers',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'num_used_workers',
          'type' => TType::I32,
          ),
        5 => array(
          'var' => 'supervisor_id',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'version',
          'type' => TType::STRING,
          ),
        7 => array(
          'var' => 'total_resources',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::DOUBLE,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::DOUBLE,
            ),
          ),
        8 => array(
          'var' => 'used_mem',
          'type' => TType::DOUBLE,
          ),
        9 => array(
          'var' => 'used_cpu',
          'type' => TType::DOUBLE,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['host'])) {
        $this->host = $vals['host'];
      }
      if (isset($vals['uptime_secs'])) {
        $this->uptime_secs = $vals['uptime_secs'];
      }
      if (isset($vals['num_workers'])) {
        $this->num_workers = $vals['num_workers'];
      }
      if (isset($vals['num_used_workers'])) {
        $this->num_used_workers = $vals['num_used_workers'];
      }
      if (isset($vals['supervisor_id'])) {
        $this->supervisor_id = $vals['supervisor_id'];
      }
      if (isset($vals['version'])) {
        $this->version = $vals['version'];
      }
      if (isset($vals['total_resources'])) {
        $this->total_resources = $vals['total_resources'];
      }
      if (isset($vals['used_mem'])) {
        $this->used_mem = $vals['used_mem'];
      }
      if (isset($vals['used_cpu'])) {
        $this->used_cpu = $vals['used_cpu'];
      }
    }
  }

  public function getName() {
    return 'SupervisorSummary';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->host);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->uptime_secs);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->num_workers);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->num_used_workers);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->supervisor_id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->version);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::MAP) {
            $this->total_resources = array();
            $_size87 = 0;
            $_ktype88 = 0;
            $_vtype89 = 0;
            $xfer += $input->readMapBegin($_ktype88, $_vtype89, $_size87);
            for ($_i91 = 0; $_i91 < $_size87; ++$_i91)
            {
              $key92 = '';
              $val93 = 0.0;
              $xfer += $input->readString($key92);
              $xfer += $input->readDouble($val93);
              $this->total_resources[$key92] = $val93;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->used_mem);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->used_cpu);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SupervisorSummary');
    if ($this->host !== null) {
      $xfer += $output->writeFieldBegin('host', TType::STRING, 1);
      $xfer += $output->writeString($this->host);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->uptime_secs !== null) {
      $xfer += $output->writeFieldBegin('uptime_secs', TType::I32, 2);
      $xfer += $output->writeI32($this->uptime_secs);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->num_workers !== null) {
      $xfer += $output->writeFieldBegin('num_workers', TType::I32, 3);
      $xfer += $output->writeI32($this->num_workers);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->num_used_workers !== null) {
      $xfer += $output->writeFieldBegin('num_used_workers', TType::I32, 4);
      $xfer += $output->writeI32($this->num_used_workers);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->supervisor_id !== null) {
      $xfer += $output->writeFieldBegin('supervisor_id', TType::STRING, 5);
      $xfer += $output->writeString($this->supervisor_id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->version !== null) {
      $xfer += $output->writeFieldBegin('version', TType::STRING, 6);
      $xfer += $output->writeString($this->version);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->total_resources !== null) {
      if (!is_array($this->total_resources)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('total_resources', TType::MAP, 7);
      {
        $output->writeMapBegin(TType::STRING, TType::DOUBLE, count($this->total_resources));
        {
          foreach ($this->total_resources as $kiter94 => $viter95)
          {
            $xfer += $output->writeString($kiter94);
            $xfer += $output->writeDouble($viter95);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->used_mem !== null) {
      $xfer += $output->writeFieldBegin('used_mem', TType::DOUBLE, 8);
      $xfer += $output->writeDouble($this->used_mem);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->used_cpu !== null) {
      $xfer += $output->writeFieldBegin('used_cpu', TType::DOUBLE, 9);
      $xfer += $output->writeDouble($this->used_cpu);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class NimbusSummary {
  static $_TSPEC;

  /**
   * @var string
   */
  public $host = null;
  /**
   * @var int
   */
  public $port = null;
  /**
   * @var int
   */
  public $uptime_secs = null;
  /**
   * @var bool
   */
  public $isLeader = null;
  /**
   * @var string
   */
  public $version = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'host',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'port',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'uptime_secs',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'isLeader',
          'type' => TType::BOOL,
          ),
        5 => array(
          'var' => 'version',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['host'])) {
        $this->host = $vals['host'];
      }
      if (isset($vals['port'])) {
        $this->port = $vals['port'];
      }
      if (isset($vals['uptime_secs'])) {
        $this->uptime_secs = $vals['uptime_secs'];
      }
      if (isset($vals['isLeader'])) {
        $this->isLeader = $vals['isLeader'];
      }
      if (isset($vals['version'])) {
        $this->version = $vals['version'];
      }
    }
  }

  public function getName() {
    return 'NimbusSummary';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->host);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->port);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->uptime_secs);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->isLeader);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->version);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('NimbusSummary');
    if ($this->host !== null) {
      $xfer += $output->writeFieldBegin('host', TType::STRING, 1);
      $xfer += $output->writeString($this->host);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->port !== null) {
      $xfer += $output->writeFieldBegin('port', TType::I32, 2);
      $xfer += $output->writeI32($this->port);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->uptime_secs !== null) {
      $xfer += $output->writeFieldBegin('uptime_secs', TType::I32, 3);
      $xfer += $output->writeI32($this->uptime_secs);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->isLeader !== null) {
      $xfer += $output->writeFieldBegin('isLeader', TType::BOOL, 4);
      $xfer += $output->writeBool($this->isLeader);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->version !== null) {
      $xfer += $output->writeFieldBegin('version', TType::STRING, 5);
      $xfer += $output->writeString($this->version);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ClusterSummary {
  static $_TSPEC;

  /**
   * @var \topology\SupervisorSummary[]
   */
  public $supervisors = null;
  /**
   * @var int
   */
  public $nimbus_uptime_secs = 0;
  /**
   * @var \topology\TopologySummary[]
   */
  public $topologies = null;
  /**
   * @var \topology\NimbusSummary[]
   */
  public $nimbuses = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'supervisors',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\topology\SupervisorSummary',
            ),
          ),
        2 => array(
          'var' => 'nimbus_uptime_secs',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'topologies',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\topology\TopologySummary',
            ),
          ),
        4 => array(
          'var' => 'nimbuses',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\topology\NimbusSummary',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['supervisors'])) {
        $this->supervisors = $vals['supervisors'];
      }
      if (isset($vals['nimbus_uptime_secs'])) {
        $this->nimbus_uptime_secs = $vals['nimbus_uptime_secs'];
      }
      if (isset($vals['topologies'])) {
        $this->topologies = $vals['topologies'];
      }
      if (isset($vals['nimbuses'])) {
        $this->nimbuses = $vals['nimbuses'];
      }
    }
  }

  public function getName() {
    return 'ClusterSummary';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->supervisors = array();
            $_size96 = 0;
            $_etype99 = 0;
            $xfer += $input->readListBegin($_etype99, $_size96);
            for ($_i100 = 0; $_i100 < $_size96; ++$_i100)
            {
              $elem101 = null;
              $elem101 = new \topology\SupervisorSummary();
              $xfer += $elem101->read($input);
              $this->supervisors []= $elem101;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->nimbus_uptime_secs);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->topologies = array();
            $_size102 = 0;
            $_etype105 = 0;
            $xfer += $input->readListBegin($_etype105, $_size102);
            for ($_i106 = 0; $_i106 < $_size102; ++$_i106)
            {
              $elem107 = null;
              $elem107 = new \topology\TopologySummary();
              $xfer += $elem107->read($input);
              $this->topologies []= $elem107;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::LST) {
            $this->nimbuses = array();
            $_size108 = 0;
            $_etype111 = 0;
            $xfer += $input->readListBegin($_etype111, $_size108);
            for ($_i112 = 0; $_i112 < $_size108; ++$_i112)
            {
              $elem113 = null;
              $elem113 = new \topology\NimbusSummary();
              $xfer += $elem113->read($input);
              $this->nimbuses []= $elem113;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ClusterSummary');
    if ($this->supervisors !== null) {
      if (!is_array($this->supervisors)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('supervisors', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->supervisors));
        {
          foreach ($this->supervisors as $iter114)
          {
            $xfer += $iter114->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->nimbus_uptime_secs !== null) {
      $xfer += $output->writeFieldBegin('nimbus_uptime_secs', TType::I32, 2);
      $xfer += $output->writeI32($this->nimbus_uptime_secs);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->topologies !== null) {
      if (!is_array($this->topologies)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('topologies', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRUCT, count($this->topologies));
        {
          foreach ($this->topologies as $iter115)
          {
            $xfer += $iter115->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->nimbuses !== null) {
      if (!is_array($this->nimbuses)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('nimbuses', TType::LST, 4);
      {
        $output->writeListBegin(TType::STRUCT, count($this->nimbuses));
        {
          foreach ($this->nimbuses as $iter116)
          {
            $xfer += $iter116->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ErrorInfo {
  static $_TSPEC;

  /**
   * @var string
   */
  public $error = null;
  /**
   * @var int
   */
  public $error_time_secs = null;
  /**
   * @var string
   */
  public $host = null;
  /**
   * @var int
   */
  public $port = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'error',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'error_time_secs',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'host',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'port',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['error'])) {
        $this->error = $vals['error'];
      }
      if (isset($vals['error_time_secs'])) {
        $this->error_time_secs = $vals['error_time_secs'];
      }
      if (isset($vals['host'])) {
        $this->host = $vals['host'];
      }
      if (isset($vals['port'])) {
        $this->port = $vals['port'];
      }
    }
  }

  public function getName() {
    return 'ErrorInfo';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->error);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->error_time_secs);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->host);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->port);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ErrorInfo');
    if ($this->error !== null) {
      $xfer += $output->writeFieldBegin('error', TType::STRING, 1);
      $xfer += $output->writeString($this->error);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->error_time_secs !== null) {
      $xfer += $output->writeFieldBegin('error_time_secs', TType::I32, 2);
      $xfer += $output->writeI32($this->error_time_secs);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->host !== null) {
      $xfer += $output->writeFieldBegin('host', TType::STRING, 3);
      $xfer += $output->writeString($this->host);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->port !== null) {
      $xfer += $output->writeFieldBegin('port', TType::I32, 4);
      $xfer += $output->writeI32($this->port);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class BoltStats {
  static $_TSPEC;

  /**
   * @var array
   */
  public $acked = null;
  /**
   * @var array
   */
  public $failed = null;
  /**
   * @var array
   */
  public $process_ms_avg = null;
  /**
   * @var array
   */
  public $executed = null;
  /**
   * @var array
   */
  public $execute_ms_avg = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'acked',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::MAP,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::MAP,
            'ktype' => TType::STRUCT,
            'vtype' => TType::I64,
            'key' => array(
              'type' => TType::STRUCT,
              'class' => '\topology\GlobalStreamId',
            ),
            'val' => array(
              'type' => TType::I64,
              ),
            ),
          ),
        2 => array(
          'var' => 'failed',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::MAP,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::MAP,
            'ktype' => TType::STRUCT,
            'vtype' => TType::I64,
            'key' => array(
              'type' => TType::STRUCT,
              'class' => '\topology\GlobalStreamId',
            ),
            'val' => array(
              'type' => TType::I64,
              ),
            ),
          ),
        3 => array(
          'var' => 'process_ms_avg',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::MAP,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::MAP,
            'ktype' => TType::STRUCT,
            'vtype' => TType::DOUBLE,
            'key' => array(
              'type' => TType::STRUCT,
              'class' => '\topology\GlobalStreamId',
            ),
            'val' => array(
              'type' => TType::DOUBLE,
              ),
            ),
          ),
        4 => array(
          'var' => 'executed',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::MAP,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::MAP,
            'ktype' => TType::STRUCT,
            'vtype' => TType::I64,
            'key' => array(
              'type' => TType::STRUCT,
              'class' => '\topology\GlobalStreamId',
            ),
            'val' => array(
              'type' => TType::I64,
              ),
            ),
          ),
        5 => array(
          'var' => 'execute_ms_avg',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::MAP,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::MAP,
            'ktype' => TType::STRUCT,
            'vtype' => TType::DOUBLE,
            'key' => array(
              'type' => TType::STRUCT,
              'class' => '\topology\GlobalStreamId',
            ),
            'val' => array(
              'type' => TType::DOUBLE,
              ),
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['acked'])) {
        $this->acked = $vals['acked'];
      }
      if (isset($vals['failed'])) {
        $this->failed = $vals['failed'];
      }
      if (isset($vals['process_ms_avg'])) {
        $this->process_ms_avg = $vals['process_ms_avg'];
      }
      if (isset($vals['executed'])) {
        $this->executed = $vals['executed'];
      }
      if (isset($vals['execute_ms_avg'])) {
        $this->execute_ms_avg = $vals['execute_ms_avg'];
      }
    }
  }

  public function getName() {
    return 'BoltStats';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->acked = array();
            $_size117 = 0;
            $_ktype118 = 0;
            $_vtype119 = 0;
            $xfer += $input->readMapBegin($_ktype118, $_vtype119, $_size117);
            for ($_i121 = 0; $_i121 < $_size117; ++$_i121)
            {
              $key122 = '';
              $val123 = array();
              $xfer += $input->readString($key122);
              $val123 = array();
              $_size124 = 0;
              $_ktype125 = 0;
              $_vtype126 = 0;
              $xfer += $input->readMapBegin($_ktype125, $_vtype126, $_size124);
              for ($_i128 = 0; $_i128 < $_size124; ++$_i128)
              {
                $key129 = new \topology\GlobalStreamId();
                $val130 = 0;
                $key129 = new \topology\GlobalStreamId();
                $xfer += $key129->read($input);
                $xfer += $input->readI64($val130);
                $val123[$key129] = $val130;
              }
              $xfer += $input->readMapEnd();
              $this->acked[$key122] = $val123;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::MAP) {
            $this->failed = array();
            $_size131 = 0;
            $_ktype132 = 0;
            $_vtype133 = 0;
            $xfer += $input->readMapBegin($_ktype132, $_vtype133, $_size131);
            for ($_i135 = 0; $_i135 < $_size131; ++$_i135)
            {
              $key136 = '';
              $val137 = array();
              $xfer += $input->readString($key136);
              $val137 = array();
              $_size138 = 0;
              $_ktype139 = 0;
              $_vtype140 = 0;
              $xfer += $input->readMapBegin($_ktype139, $_vtype140, $_size138);
              for ($_i142 = 0; $_i142 < $_size138; ++$_i142)
              {
                $key143 = new \topology\GlobalStreamId();
                $val144 = 0;
                $key143 = new \topology\GlobalStreamId();
                $xfer += $key143->read($input);
                $xfer += $input->readI64($val144);
                $val137[$key143] = $val144;
              }
              $xfer += $input->readMapEnd();
              $this->failed[$key136] = $val137;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::MAP) {
            $this->process_ms_avg = array();
            $_size145 = 0;
            $_ktype146 = 0;
            $_vtype147 = 0;
            $xfer += $input->readMapBegin($_ktype146, $_vtype147, $_size145);
            for ($_i149 = 0; $_i149 < $_size145; ++$_i149)
            {
              $key150 = '';
              $val151 = array();
              $xfer += $input->readString($key150);
              $val151 = array();
              $_size152 = 0;
              $_ktype153 = 0;
              $_vtype154 = 0;
              $xfer += $input->readMapBegin($_ktype153, $_vtype154, $_size152);
              for ($_i156 = 0; $_i156 < $_size152; ++$_i156)
              {
                $key157 = new \topology\GlobalStreamId();
                $val158 = 0.0;
                $key157 = new \topology\GlobalStreamId();
                $xfer += $key157->read($input);
                $xfer += $input->readDouble($val158);
                $val151[$key157] = $val158;
              }
              $xfer += $input->readMapEnd();
              $this->process_ms_avg[$key150] = $val151;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::MAP) {
            $this->executed = array();
            $_size159 = 0;
            $_ktype160 = 0;
            $_vtype161 = 0;
            $xfer += $input->readMapBegin($_ktype160, $_vtype161, $_size159);
            for ($_i163 = 0; $_i163 < $_size159; ++$_i163)
            {
              $key164 = '';
              $val165 = array();
              $xfer += $input->readString($key164);
              $val165 = array();
              $_size166 = 0;
              $_ktype167 = 0;
              $_vtype168 = 0;
              $xfer += $input->readMapBegin($_ktype167, $_vtype168, $_size166);
              for ($_i170 = 0; $_i170 < $_size166; ++$_i170)
              {
                $key171 = new \topology\GlobalStreamId();
                $val172 = 0;
                $key171 = new \topology\GlobalStreamId();
                $xfer += $key171->read($input);
                $xfer += $input->readI64($val172);
                $val165[$key171] = $val172;
              }
              $xfer += $input->readMapEnd();
              $this->executed[$key164] = $val165;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::MAP) {
            $this->execute_ms_avg = array();
            $_size173 = 0;
            $_ktype174 = 0;
            $_vtype175 = 0;
            $xfer += $input->readMapBegin($_ktype174, $_vtype175, $_size173);
            for ($_i177 = 0; $_i177 < $_size173; ++$_i177)
            {
              $key178 = '';
              $val179 = array();
              $xfer += $input->readString($key178);
              $val179 = array();
              $_size180 = 0;
              $_ktype181 = 0;
              $_vtype182 = 0;
              $xfer += $input->readMapBegin($_ktype181, $_vtype182, $_size180);
              for ($_i184 = 0; $_i184 < $_size180; ++$_i184)
              {
                $key185 = new \topology\GlobalStreamId();
                $val186 = 0.0;
                $key185 = new \topology\GlobalStreamId();
                $xfer += $key185->read($input);
                $xfer += $input->readDouble($val186);
                $val179[$key185] = $val186;
              }
              $xfer += $input->readMapEnd();
              $this->execute_ms_avg[$key178] = $val179;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BoltStats');
    if ($this->acked !== null) {
      if (!is_array($this->acked)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('acked', TType::MAP, 1);
      {
        $output->writeMapBegin(TType::STRING, TType::MAP, count($this->acked));
        {
          foreach ($this->acked as $kiter187 => $viter188)
          {
            $xfer += $output->writeString($kiter187);
            {
              $output->writeMapBegin(TType::STRUCT, TType::I64, count($viter188));
              {
                foreach ($viter188 as $kiter189 => $viter190)
                {
                  $xfer += $kiter189->write($output);
                  $xfer += $output->writeI64($viter190);
                }
              }
              $output->writeMapEnd();
            }
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->failed !== null) {
      if (!is_array($this->failed)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('failed', TType::MAP, 2);
      {
        $output->writeMapBegin(TType::STRING, TType::MAP, count($this->failed));
        {
          foreach ($this->failed as $kiter191 => $viter192)
          {
            $xfer += $output->writeString($kiter191);
            {
              $output->writeMapBegin(TType::STRUCT, TType::I64, count($viter192));
              {
                foreach ($viter192 as $kiter193 => $viter194)
                {
                  $xfer += $kiter193->write($output);
                  $xfer += $output->writeI64($viter194);
                }
              }
              $output->writeMapEnd();
            }
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->process_ms_avg !== null) {
      if (!is_array($this->process_ms_avg)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('process_ms_avg', TType::MAP, 3);
      {
        $output->writeMapBegin(TType::STRING, TType::MAP, count($this->process_ms_avg));
        {
          foreach ($this->process_ms_avg as $kiter195 => $viter196)
          {
            $xfer += $output->writeString($kiter195);
            {
              $output->writeMapBegin(TType::STRUCT, TType::DOUBLE, count($viter196));
              {
                foreach ($viter196 as $kiter197 => $viter198)
                {
                  $xfer += $kiter197->write($output);
                  $xfer += $output->writeDouble($viter198);
                }
              }
              $output->writeMapEnd();
            }
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->executed !== null) {
      if (!is_array($this->executed)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('executed', TType::MAP, 4);
      {
        $output->writeMapBegin(TType::STRING, TType::MAP, count($this->executed));
        {
          foreach ($this->executed as $kiter199 => $viter200)
          {
            $xfer += $output->writeString($kiter199);
            {
              $output->writeMapBegin(TType::STRUCT, TType::I64, count($viter200));
              {
                foreach ($viter200 as $kiter201 => $viter202)
                {
                  $xfer += $kiter201->write($output);
                  $xfer += $output->writeI64($viter202);
                }
              }
              $output->writeMapEnd();
            }
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->execute_ms_avg !== null) {
      if (!is_array($this->execute_ms_avg)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('execute_ms_avg', TType::MAP, 5);
      {
        $output->writeMapBegin(TType::STRING, TType::MAP, count($this->execute_ms_avg));
        {
          foreach ($this->execute_ms_avg as $kiter203 => $viter204)
          {
            $xfer += $output->writeString($kiter203);
            {
              $output->writeMapBegin(TType::STRUCT, TType::DOUBLE, count($viter204));
              {
                foreach ($viter204 as $kiter205 => $viter206)
                {
                  $xfer += $kiter205->write($output);
                  $xfer += $output->writeDouble($viter206);
                }
              }
              $output->writeMapEnd();
            }
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SpoutStats {
  static $_TSPEC;

  /**
   * @var array
   */
  public $acked = null;
  /**
   * @var array
   */
  public $failed = null;
  /**
   * @var array
   */
  public $complete_ms_avg = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'acked',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::MAP,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::MAP,
            'ktype' => TType::STRING,
            'vtype' => TType::I64,
            'key' => array(
              'type' => TType::STRING,
            ),
            'val' => array(
              'type' => TType::I64,
              ),
            ),
          ),
        2 => array(
          'var' => 'failed',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::MAP,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::MAP,
            'ktype' => TType::STRING,
            'vtype' => TType::I64,
            'key' => array(
              'type' => TType::STRING,
            ),
            'val' => array(
              'type' => TType::I64,
              ),
            ),
          ),
        3 => array(
          'var' => 'complete_ms_avg',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::MAP,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::MAP,
            'ktype' => TType::STRING,
            'vtype' => TType::DOUBLE,
            'key' => array(
              'type' => TType::STRING,
            ),
            'val' => array(
              'type' => TType::DOUBLE,
              ),
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['acked'])) {
        $this->acked = $vals['acked'];
      }
      if (isset($vals['failed'])) {
        $this->failed = $vals['failed'];
      }
      if (isset($vals['complete_ms_avg'])) {
        $this->complete_ms_avg = $vals['complete_ms_avg'];
      }
    }
  }

  public function getName() {
    return 'SpoutStats';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->acked = array();
            $_size207 = 0;
            $_ktype208 = 0;
            $_vtype209 = 0;
            $xfer += $input->readMapBegin($_ktype208, $_vtype209, $_size207);
            for ($_i211 = 0; $_i211 < $_size207; ++$_i211)
            {
              $key212 = '';
              $val213 = array();
              $xfer += $input->readString($key212);
              $val213 = array();
              $_size214 = 0;
              $_ktype215 = 0;
              $_vtype216 = 0;
              $xfer += $input->readMapBegin($_ktype215, $_vtype216, $_size214);
              for ($_i218 = 0; $_i218 < $_size214; ++$_i218)
              {
                $key219 = '';
                $val220 = 0;
                $xfer += $input->readString($key219);
                $xfer += $input->readI64($val220);
                $val213[$key219] = $val220;
              }
              $xfer += $input->readMapEnd();
              $this->acked[$key212] = $val213;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::MAP) {
            $this->failed = array();
            $_size221 = 0;
            $_ktype222 = 0;
            $_vtype223 = 0;
            $xfer += $input->readMapBegin($_ktype222, $_vtype223, $_size221);
            for ($_i225 = 0; $_i225 < $_size221; ++$_i225)
            {
              $key226 = '';
              $val227 = array();
              $xfer += $input->readString($key226);
              $val227 = array();
              $_size228 = 0;
              $_ktype229 = 0;
              $_vtype230 = 0;
              $xfer += $input->readMapBegin($_ktype229, $_vtype230, $_size228);
              for ($_i232 = 0; $_i232 < $_size228; ++$_i232)
              {
                $key233 = '';
                $val234 = 0;
                $xfer += $input->readString($key233);
                $xfer += $input->readI64($val234);
                $val227[$key233] = $val234;
              }
              $xfer += $input->readMapEnd();
              $this->failed[$key226] = $val227;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::MAP) {
            $this->complete_ms_avg = array();
            $_size235 = 0;
            $_ktype236 = 0;
            $_vtype237 = 0;
            $xfer += $input->readMapBegin($_ktype236, $_vtype237, $_size235);
            for ($_i239 = 0; $_i239 < $_size235; ++$_i239)
            {
              $key240 = '';
              $val241 = array();
              $xfer += $input->readString($key240);
              $val241 = array();
              $_size242 = 0;
              $_ktype243 = 0;
              $_vtype244 = 0;
              $xfer += $input->readMapBegin($_ktype243, $_vtype244, $_size242);
              for ($_i246 = 0; $_i246 < $_size242; ++$_i246)
              {
                $key247 = '';
                $val248 = 0.0;
                $xfer += $input->readString($key247);
                $xfer += $input->readDouble($val248);
                $val241[$key247] = $val248;
              }
              $xfer += $input->readMapEnd();
              $this->complete_ms_avg[$key240] = $val241;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SpoutStats');
    if ($this->acked !== null) {
      if (!is_array($this->acked)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('acked', TType::MAP, 1);
      {
        $output->writeMapBegin(TType::STRING, TType::MAP, count($this->acked));
        {
          foreach ($this->acked as $kiter249 => $viter250)
          {
            $xfer += $output->writeString($kiter249);
            {
              $output->writeMapBegin(TType::STRING, TType::I64, count($viter250));
              {
                foreach ($viter250 as $kiter251 => $viter252)
                {
                  $xfer += $output->writeString($kiter251);
                  $xfer += $output->writeI64($viter252);
                }
              }
              $output->writeMapEnd();
            }
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->failed !== null) {
      if (!is_array($this->failed)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('failed', TType::MAP, 2);
      {
        $output->writeMapBegin(TType::STRING, TType::MAP, count($this->failed));
        {
          foreach ($this->failed as $kiter253 => $viter254)
          {
            $xfer += $output->writeString($kiter253);
            {
              $output->writeMapBegin(TType::STRING, TType::I64, count($viter254));
              {
                foreach ($viter254 as $kiter255 => $viter256)
                {
                  $xfer += $output->writeString($kiter255);
                  $xfer += $output->writeI64($viter256);
                }
              }
              $output->writeMapEnd();
            }
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->complete_ms_avg !== null) {
      if (!is_array($this->complete_ms_avg)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('complete_ms_avg', TType::MAP, 3);
      {
        $output->writeMapBegin(TType::STRING, TType::MAP, count($this->complete_ms_avg));
        {
          foreach ($this->complete_ms_avg as $kiter257 => $viter258)
          {
            $xfer += $output->writeString($kiter257);
            {
              $output->writeMapBegin(TType::STRING, TType::DOUBLE, count($viter258));
              {
                foreach ($viter258 as $kiter259 => $viter260)
                {
                  $xfer += $output->writeString($kiter259);
                  $xfer += $output->writeDouble($viter260);
                }
              }
              $output->writeMapEnd();
            }
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ExecutorSpecificStats {
  static $_TSPEC;

  /**
   * @var \topology\BoltStats
   */
  public $bolt = null;
  /**
   * @var \topology\SpoutStats
   */
  public $spout = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'bolt',
          'type' => TType::STRUCT,
          'class' => '\topology\BoltStats',
          ),
        2 => array(
          'var' => 'spout',
          'type' => TType::STRUCT,
          'class' => '\topology\SpoutStats',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['bolt'])) {
        $this->bolt = $vals['bolt'];
      }
      if (isset($vals['spout'])) {
        $this->spout = $vals['spout'];
      }
    }
  }

  public function getName() {
    return 'ExecutorSpecificStats';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->bolt = new \topology\BoltStats();
            $xfer += $this->bolt->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->spout = new \topology\SpoutStats();
            $xfer += $this->spout->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ExecutorSpecificStats');
    if ($this->bolt !== null) {
      if (!is_object($this->bolt)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('bolt', TType::STRUCT, 1);
      $xfer += $this->bolt->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->spout !== null) {
      if (!is_object($this->spout)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('spout', TType::STRUCT, 2);
      $xfer += $this->spout->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ExecutorStats {
  static $_TSPEC;

  /**
   * @var array
   */
  public $emitted = null;
  /**
   * @var array
   */
  public $transferred = null;
  /**
   * @var \topology\ExecutorSpecificStats
   */
  public $specific = null;
  /**
   * @var double
   */
  public $rate = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'emitted',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::MAP,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::MAP,
            'ktype' => TType::STRING,
            'vtype' => TType::I64,
            'key' => array(
              'type' => TType::STRING,
            ),
            'val' => array(
              'type' => TType::I64,
              ),
            ),
          ),
        2 => array(
          'var' => 'transferred',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::MAP,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::MAP,
            'ktype' => TType::STRING,
            'vtype' => TType::I64,
            'key' => array(
              'type' => TType::STRING,
            ),
            'val' => array(
              'type' => TType::I64,
              ),
            ),
          ),
        3 => array(
          'var' => 'specific',
          'type' => TType::STRUCT,
          'class' => '\topology\ExecutorSpecificStats',
          ),
        4 => array(
          'var' => 'rate',
          'type' => TType::DOUBLE,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['emitted'])) {
        $this->emitted = $vals['emitted'];
      }
      if (isset($vals['transferred'])) {
        $this->transferred = $vals['transferred'];
      }
      if (isset($vals['specific'])) {
        $this->specific = $vals['specific'];
      }
      if (isset($vals['rate'])) {
        $this->rate = $vals['rate'];
      }
    }
  }

  public function getName() {
    return 'ExecutorStats';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->emitted = array();
            $_size261 = 0;
            $_ktype262 = 0;
            $_vtype263 = 0;
            $xfer += $input->readMapBegin($_ktype262, $_vtype263, $_size261);
            for ($_i265 = 0; $_i265 < $_size261; ++$_i265)
            {
              $key266 = '';
              $val267 = array();
              $xfer += $input->readString($key266);
              $val267 = array();
              $_size268 = 0;
              $_ktype269 = 0;
              $_vtype270 = 0;
              $xfer += $input->readMapBegin($_ktype269, $_vtype270, $_size268);
              for ($_i272 = 0; $_i272 < $_size268; ++$_i272)
              {
                $key273 = '';
                $val274 = 0;
                $xfer += $input->readString($key273);
                $xfer += $input->readI64($val274);
                $val267[$key273] = $val274;
              }
              $xfer += $input->readMapEnd();
              $this->emitted[$key266] = $val267;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::MAP) {
            $this->transferred = array();
            $_size275 = 0;
            $_ktype276 = 0;
            $_vtype277 = 0;
            $xfer += $input->readMapBegin($_ktype276, $_vtype277, $_size275);
            for ($_i279 = 0; $_i279 < $_size275; ++$_i279)
            {
              $key280 = '';
              $val281 = array();
              $xfer += $input->readString($key280);
              $val281 = array();
              $_size282 = 0;
              $_ktype283 = 0;
              $_vtype284 = 0;
              $xfer += $input->readMapBegin($_ktype283, $_vtype284, $_size282);
              for ($_i286 = 0; $_i286 < $_size282; ++$_i286)
              {
                $key287 = '';
                $val288 = 0;
                $xfer += $input->readString($key287);
                $xfer += $input->readI64($val288);
                $val281[$key287] = $val288;
              }
              $xfer += $input->readMapEnd();
              $this->transferred[$key280] = $val281;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->specific = new \topology\ExecutorSpecificStats();
            $xfer += $this->specific->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->rate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ExecutorStats');
    if ($this->emitted !== null) {
      if (!is_array($this->emitted)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('emitted', TType::MAP, 1);
      {
        $output->writeMapBegin(TType::STRING, TType::MAP, count($this->emitted));
        {
          foreach ($this->emitted as $kiter289 => $viter290)
          {
            $xfer += $output->writeString($kiter289);
            {
              $output->writeMapBegin(TType::STRING, TType::I64, count($viter290));
              {
                foreach ($viter290 as $kiter291 => $viter292)
                {
                  $xfer += $output->writeString($kiter291);
                  $xfer += $output->writeI64($viter292);
                }
              }
              $output->writeMapEnd();
            }
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->transferred !== null) {
      if (!is_array($this->transferred)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('transferred', TType::MAP, 2);
      {
        $output->writeMapBegin(TType::STRING, TType::MAP, count($this->transferred));
        {
          foreach ($this->transferred as $kiter293 => $viter294)
          {
            $xfer += $output->writeString($kiter293);
            {
              $output->writeMapBegin(TType::STRING, TType::I64, count($viter294));
              {
                foreach ($viter294 as $kiter295 => $viter296)
                {
                  $xfer += $output->writeString($kiter295);
                  $xfer += $output->writeI64($viter296);
                }
              }
              $output->writeMapEnd();
            }
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->specific !== null) {
      if (!is_object($this->specific)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('specific', TType::STRUCT, 3);
      $xfer += $this->specific->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->rate !== null) {
      $xfer += $output->writeFieldBegin('rate', TType::DOUBLE, 4);
      $xfer += $output->writeDouble($this->rate);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ExecutorInfo {
  static $_TSPEC;

  /**
   * @var int
   */
  public $task_start = null;
  /**
   * @var int
   */
  public $task_end = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'task_start',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'task_end',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['task_start'])) {
        $this->task_start = $vals['task_start'];
      }
      if (isset($vals['task_end'])) {
        $this->task_end = $vals['task_end'];
      }
    }
  }

  public function getName() {
    return 'ExecutorInfo';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->task_start);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->task_end);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ExecutorInfo');
    if ($this->task_start !== null) {
      $xfer += $output->writeFieldBegin('task_start', TType::I32, 1);
      $xfer += $output->writeI32($this->task_start);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->task_end !== null) {
      $xfer += $output->writeFieldBegin('task_end', TType::I32, 2);
      $xfer += $output->writeI32($this->task_end);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ExecutorSummary {
  static $_TSPEC;

  /**
   * @var \topology\ExecutorInfo
   */
  public $executor_info = null;
  /**
   * @var string
   */
  public $component_id = null;
  /**
   * @var string
   */
  public $host = null;
  /**
   * @var int
   */
  public $port = null;
  /**
   * @var int
   */
  public $uptime_secs = null;
  /**
   * @var \topology\ExecutorStats
   */
  public $stats = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'executor_info',
          'type' => TType::STRUCT,
          'class' => '\topology\ExecutorInfo',
          ),
        2 => array(
          'var' => 'component_id',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'host',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'port',
          'type' => TType::I32,
          ),
        5 => array(
          'var' => 'uptime_secs',
          'type' => TType::I32,
          ),
        7 => array(
          'var' => 'stats',
          'type' => TType::STRUCT,
          'class' => '\topology\ExecutorStats',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['executor_info'])) {
        $this->executor_info = $vals['executor_info'];
      }
      if (isset($vals['component_id'])) {
        $this->component_id = $vals['component_id'];
      }
      if (isset($vals['host'])) {
        $this->host = $vals['host'];
      }
      if (isset($vals['port'])) {
        $this->port = $vals['port'];
      }
      if (isset($vals['uptime_secs'])) {
        $this->uptime_secs = $vals['uptime_secs'];
      }
      if (isset($vals['stats'])) {
        $this->stats = $vals['stats'];
      }
    }
  }

  public function getName() {
    return 'ExecutorSummary';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->executor_info = new \topology\ExecutorInfo();
            $xfer += $this->executor_info->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->component_id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->host);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->port);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->uptime_secs);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRUCT) {
            $this->stats = new \topology\ExecutorStats();
            $xfer += $this->stats->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ExecutorSummary');
    if ($this->executor_info !== null) {
      if (!is_object($this->executor_info)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('executor_info', TType::STRUCT, 1);
      $xfer += $this->executor_info->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->component_id !== null) {
      $xfer += $output->writeFieldBegin('component_id', TType::STRING, 2);
      $xfer += $output->writeString($this->component_id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->host !== null) {
      $xfer += $output->writeFieldBegin('host', TType::STRING, 3);
      $xfer += $output->writeString($this->host);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->port !== null) {
      $xfer += $output->writeFieldBegin('port', TType::I32, 4);
      $xfer += $output->writeI32($this->port);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->uptime_secs !== null) {
      $xfer += $output->writeFieldBegin('uptime_secs', TType::I32, 5);
      $xfer += $output->writeI32($this->uptime_secs);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->stats !== null) {
      if (!is_object($this->stats)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('stats', TType::STRUCT, 7);
      $xfer += $this->stats->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class DebugOptions {
  static $_TSPEC;

  /**
   * @var bool
   */
  public $enable = null;
  /**
   * @var double
   */
  public $samplingpct = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'enable',
          'type' => TType::BOOL,
          ),
        2 => array(
          'var' => 'samplingpct',
          'type' => TType::DOUBLE,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['enable'])) {
        $this->enable = $vals['enable'];
      }
      if (isset($vals['samplingpct'])) {
        $this->samplingpct = $vals['samplingpct'];
      }
    }
  }

  public function getName() {
    return 'DebugOptions';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->enable);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->samplingpct);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DebugOptions');
    if ($this->enable !== null) {
      $xfer += $output->writeFieldBegin('enable', TType::BOOL, 1);
      $xfer += $output->writeBool($this->enable);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->samplingpct !== null) {
      $xfer += $output->writeFieldBegin('samplingpct', TType::DOUBLE, 2);
      $xfer += $output->writeDouble($this->samplingpct);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TopologyInfo {
  static $_TSPEC;

  /**
   * @var string
   */
  public $id = null;
  /**
   * @var string
   */
  public $name = null;
  /**
   * @var int
   */
  public $uptime_secs = null;
  /**
   * @var \topology\ExecutorSummary[]
   */
  public $executors = null;
  /**
   * @var string
   */
  public $status = null;
  /**
   * @var array
   */
  public $errors = null;
  /**
   * @var array
   */
  public $component_debug = null;
  /**
   * @var string
   */
  public $sched_status = null;
  /**
   * @var string
   */
  public $owner = null;
  /**
   * @var int
   */
  public $replication_count = null;
  /**
   * @var double
   */
  public $requested_memonheap = null;
  /**
   * @var double
   */
  public $requested_memoffheap = null;
  /**
   * @var double
   */
  public $requested_cpu = null;
  /**
   * @var double
   */
  public $assigned_memonheap = null;
  /**
   * @var double
   */
  public $assigned_memoffheap = null;
  /**
   * @var double
   */
  public $assigned_cpu = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'id',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'uptime_secs',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'executors',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\topology\ExecutorSummary',
            ),
          ),
        5 => array(
          'var' => 'status',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'errors',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::LST,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::LST,
            'etype' => TType::STRUCT,
            'elem' => array(
              'type' => TType::STRUCT,
              'class' => '\topology\ErrorInfo',
              ),
            ),
          ),
        7 => array(
          'var' => 'component_debug',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRUCT,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRUCT,
            'class' => '\topology\DebugOptions',
            ),
          ),
        513 => array(
          'var' => 'sched_status',
          'type' => TType::STRING,
          ),
        514 => array(
          'var' => 'owner',
          'type' => TType::STRING,
          ),
        515 => array(
          'var' => 'replication_count',
          'type' => TType::I32,
          ),
        521 => array(
          'var' => 'requested_memonheap',
          'type' => TType::DOUBLE,
          ),
        522 => array(
          'var' => 'requested_memoffheap',
          'type' => TType::DOUBLE,
          ),
        523 => array(
          'var' => 'requested_cpu',
          'type' => TType::DOUBLE,
          ),
        524 => array(
          'var' => 'assigned_memonheap',
          'type' => TType::DOUBLE,
          ),
        525 => array(
          'var' => 'assigned_memoffheap',
          'type' => TType::DOUBLE,
          ),
        526 => array(
          'var' => 'assigned_cpu',
          'type' => TType::DOUBLE,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['id'])) {
        $this->id = $vals['id'];
      }
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['uptime_secs'])) {
        $this->uptime_secs = $vals['uptime_secs'];
      }
      if (isset($vals['executors'])) {
        $this->executors = $vals['executors'];
      }
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
      if (isset($vals['errors'])) {
        $this->errors = $vals['errors'];
      }
      if (isset($vals['component_debug'])) {
        $this->component_debug = $vals['component_debug'];
      }
      if (isset($vals['sched_status'])) {
        $this->sched_status = $vals['sched_status'];
      }
      if (isset($vals['owner'])) {
        $this->owner = $vals['owner'];
      }
      if (isset($vals['replication_count'])) {
        $this->replication_count = $vals['replication_count'];
      }
      if (isset($vals['requested_memonheap'])) {
        $this->requested_memonheap = $vals['requested_memonheap'];
      }
      if (isset($vals['requested_memoffheap'])) {
        $this->requested_memoffheap = $vals['requested_memoffheap'];
      }
      if (isset($vals['requested_cpu'])) {
        $this->requested_cpu = $vals['requested_cpu'];
      }
      if (isset($vals['assigned_memonheap'])) {
        $this->assigned_memonheap = $vals['assigned_memonheap'];
      }
      if (isset($vals['assigned_memoffheap'])) {
        $this->assigned_memoffheap = $vals['assigned_memoffheap'];
      }
      if (isset($vals['assigned_cpu'])) {
        $this->assigned_cpu = $vals['assigned_cpu'];
      }
    }
  }

  public function getName() {
    return 'TopologyInfo';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->uptime_secs);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::LST) {
            $this->executors = array();
            $_size297 = 0;
            $_etype300 = 0;
            $xfer += $input->readListBegin($_etype300, $_size297);
            for ($_i301 = 0; $_i301 < $_size297; ++$_i301)
            {
              $elem302 = null;
              $elem302 = new \topology\ExecutorSummary();
              $xfer += $elem302->read($input);
              $this->executors []= $elem302;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->status);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::MAP) {
            $this->errors = array();
            $_size303 = 0;
            $_ktype304 = 0;
            $_vtype305 = 0;
            $xfer += $input->readMapBegin($_ktype304, $_vtype305, $_size303);
            for ($_i307 = 0; $_i307 < $_size303; ++$_i307)
            {
              $key308 = '';
              $val309 = array();
              $xfer += $input->readString($key308);
              $val309 = array();
              $_size310 = 0;
              $_etype313 = 0;
              $xfer += $input->readListBegin($_etype313, $_size310);
              for ($_i314 = 0; $_i314 < $_size310; ++$_i314)
              {
                $elem315 = null;
                $elem315 = new \topology\ErrorInfo();
                $xfer += $elem315->read($input);
                $val309 []= $elem315;
              }
              $xfer += $input->readListEnd();
              $this->errors[$key308] = $val309;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::MAP) {
            $this->component_debug = array();
            $_size316 = 0;
            $_ktype317 = 0;
            $_vtype318 = 0;
            $xfer += $input->readMapBegin($_ktype317, $_vtype318, $_size316);
            for ($_i320 = 0; $_i320 < $_size316; ++$_i320)
            {
              $key321 = '';
              $val322 = new \topology\DebugOptions();
              $xfer += $input->readString($key321);
              $val322 = new \topology\DebugOptions();
              $xfer += $val322->read($input);
              $this->component_debug[$key321] = $val322;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 513:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->sched_status);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 514:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->owner);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 515:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->replication_count);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 521:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->requested_memonheap);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 522:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->requested_memoffheap);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 523:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->requested_cpu);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 524:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->assigned_memonheap);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 525:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->assigned_memoffheap);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 526:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->assigned_cpu);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TopologyInfo');
    if ($this->id !== null) {
      $xfer += $output->writeFieldBegin('id', TType::STRING, 1);
      $xfer += $output->writeString($this->id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 2);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->uptime_secs !== null) {
      $xfer += $output->writeFieldBegin('uptime_secs', TType::I32, 3);
      $xfer += $output->writeI32($this->uptime_secs);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->executors !== null) {
      if (!is_array($this->executors)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('executors', TType::LST, 4);
      {
        $output->writeListBegin(TType::STRUCT, count($this->executors));
        {
          foreach ($this->executors as $iter323)
          {
            $xfer += $iter323->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->status !== null) {
      $xfer += $output->writeFieldBegin('status', TType::STRING, 5);
      $xfer += $output->writeString($this->status);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->errors !== null) {
      if (!is_array($this->errors)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('errors', TType::MAP, 6);
      {
        $output->writeMapBegin(TType::STRING, TType::LST, count($this->errors));
        {
          foreach ($this->errors as $kiter324 => $viter325)
          {
            $xfer += $output->writeString($kiter324);
            {
              $output->writeListBegin(TType::STRUCT, count($viter325));
              {
                foreach ($viter325 as $iter326)
                {
                  $xfer += $iter326->write($output);
                }
              }
              $output->writeListEnd();
            }
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->component_debug !== null) {
      if (!is_array($this->component_debug)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('component_debug', TType::MAP, 7);
      {
        $output->writeMapBegin(TType::STRING, TType::STRUCT, count($this->component_debug));
        {
          foreach ($this->component_debug as $kiter327 => $viter328)
          {
            $xfer += $output->writeString($kiter327);
            $xfer += $viter328->write($output);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->sched_status !== null) {
      $xfer += $output->writeFieldBegin('sched_status', TType::STRING, 513);
      $xfer += $output->writeString($this->sched_status);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->owner !== null) {
      $xfer += $output->writeFieldBegin('owner', TType::STRING, 514);
      $xfer += $output->writeString($this->owner);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->replication_count !== null) {
      $xfer += $output->writeFieldBegin('replication_count', TType::I32, 515);
      $xfer += $output->writeI32($this->replication_count);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->requested_memonheap !== null) {
      $xfer += $output->writeFieldBegin('requested_memonheap', TType::DOUBLE, 521);
      $xfer += $output->writeDouble($this->requested_memonheap);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->requested_memoffheap !== null) {
      $xfer += $output->writeFieldBegin('requested_memoffheap', TType::DOUBLE, 522);
      $xfer += $output->writeDouble($this->requested_memoffheap);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->requested_cpu !== null) {
      $xfer += $output->writeFieldBegin('requested_cpu', TType::DOUBLE, 523);
      $xfer += $output->writeDouble($this->requested_cpu);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->assigned_memonheap !== null) {
      $xfer += $output->writeFieldBegin('assigned_memonheap', TType::DOUBLE, 524);
      $xfer += $output->writeDouble($this->assigned_memonheap);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->assigned_memoffheap !== null) {
      $xfer += $output->writeFieldBegin('assigned_memoffheap', TType::DOUBLE, 525);
      $xfer += $output->writeDouble($this->assigned_memoffheap);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->assigned_cpu !== null) {
      $xfer += $output->writeFieldBegin('assigned_cpu', TType::DOUBLE, 526);
      $xfer += $output->writeDouble($this->assigned_cpu);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class CommonAggregateStats {
  static $_TSPEC;

  /**
   * @var int
   */
  public $num_executors = null;
  /**
   * @var int
   */
  public $num_tasks = null;
  /**
   * @var int
   */
  public $emitted = null;
  /**
   * @var int
   */
  public $transferred = null;
  /**
   * @var int
   */
  public $acked = null;
  /**
   * @var int
   */
  public $failed = null;
  /**
   * @var array
   */
  public $resources_map = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'num_executors',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'num_tasks',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'emitted',
          'type' => TType::I64,
          ),
        4 => array(
          'var' => 'transferred',
          'type' => TType::I64,
          ),
        5 => array(
          'var' => 'acked',
          'type' => TType::I64,
          ),
        6 => array(
          'var' => 'failed',
          'type' => TType::I64,
          ),
        7 => array(
          'var' => 'resources_map',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::DOUBLE,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::DOUBLE,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['num_executors'])) {
        $this->num_executors = $vals['num_executors'];
      }
      if (isset($vals['num_tasks'])) {
        $this->num_tasks = $vals['num_tasks'];
      }
      if (isset($vals['emitted'])) {
        $this->emitted = $vals['emitted'];
      }
      if (isset($vals['transferred'])) {
        $this->transferred = $vals['transferred'];
      }
      if (isset($vals['acked'])) {
        $this->acked = $vals['acked'];
      }
      if (isset($vals['failed'])) {
        $this->failed = $vals['failed'];
      }
      if (isset($vals['resources_map'])) {
        $this->resources_map = $vals['resources_map'];
      }
    }
  }

  public function getName() {
    return 'CommonAggregateStats';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->num_executors);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->num_tasks);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->emitted);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->transferred);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->acked);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->failed);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::MAP) {
            $this->resources_map = array();
            $_size329 = 0;
            $_ktype330 = 0;
            $_vtype331 = 0;
            $xfer += $input->readMapBegin($_ktype330, $_vtype331, $_size329);
            for ($_i333 = 0; $_i333 < $_size329; ++$_i333)
            {
              $key334 = '';
              $val335 = 0.0;
              $xfer += $input->readString($key334);
              $xfer += $input->readDouble($val335);
              $this->resources_map[$key334] = $val335;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('CommonAggregateStats');
    if ($this->num_executors !== null) {
      $xfer += $output->writeFieldBegin('num_executors', TType::I32, 1);
      $xfer += $output->writeI32($this->num_executors);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->num_tasks !== null) {
      $xfer += $output->writeFieldBegin('num_tasks', TType::I32, 2);
      $xfer += $output->writeI32($this->num_tasks);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->emitted !== null) {
      $xfer += $output->writeFieldBegin('emitted', TType::I64, 3);
      $xfer += $output->writeI64($this->emitted);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->transferred !== null) {
      $xfer += $output->writeFieldBegin('transferred', TType::I64, 4);
      $xfer += $output->writeI64($this->transferred);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->acked !== null) {
      $xfer += $output->writeFieldBegin('acked', TType::I64, 5);
      $xfer += $output->writeI64($this->acked);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->failed !== null) {
      $xfer += $output->writeFieldBegin('failed', TType::I64, 6);
      $xfer += $output->writeI64($this->failed);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->resources_map !== null) {
      if (!is_array($this->resources_map)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('resources_map', TType::MAP, 7);
      {
        $output->writeMapBegin(TType::STRING, TType::DOUBLE, count($this->resources_map));
        {
          foreach ($this->resources_map as $kiter336 => $viter337)
          {
            $xfer += $output->writeString($kiter336);
            $xfer += $output->writeDouble($viter337);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SpoutAggregateStats {
  static $_TSPEC;

  /**
   * @var double
   */
  public $complete_latency_ms = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'complete_latency_ms',
          'type' => TType::DOUBLE,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['complete_latency_ms'])) {
        $this->complete_latency_ms = $vals['complete_latency_ms'];
      }
    }
  }

  public function getName() {
    return 'SpoutAggregateStats';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->complete_latency_ms);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SpoutAggregateStats');
    if ($this->complete_latency_ms !== null) {
      $xfer += $output->writeFieldBegin('complete_latency_ms', TType::DOUBLE, 1);
      $xfer += $output->writeDouble($this->complete_latency_ms);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class BoltAggregateStats {
  static $_TSPEC;

  /**
   * @var double
   */
  public $execute_latency_ms = null;
  /**
   * @var double
   */
  public $process_latency_ms = null;
  /**
   * @var int
   */
  public $executed = null;
  /**
   * @var double
   */
  public $capacity = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'execute_latency_ms',
          'type' => TType::DOUBLE,
          ),
        2 => array(
          'var' => 'process_latency_ms',
          'type' => TType::DOUBLE,
          ),
        3 => array(
          'var' => 'executed',
          'type' => TType::I64,
          ),
        4 => array(
          'var' => 'capacity',
          'type' => TType::DOUBLE,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['execute_latency_ms'])) {
        $this->execute_latency_ms = $vals['execute_latency_ms'];
      }
      if (isset($vals['process_latency_ms'])) {
        $this->process_latency_ms = $vals['process_latency_ms'];
      }
      if (isset($vals['executed'])) {
        $this->executed = $vals['executed'];
      }
      if (isset($vals['capacity'])) {
        $this->capacity = $vals['capacity'];
      }
    }
  }

  public function getName() {
    return 'BoltAggregateStats';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->execute_latency_ms);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->process_latency_ms);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->executed);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->capacity);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BoltAggregateStats');
    if ($this->execute_latency_ms !== null) {
      $xfer += $output->writeFieldBegin('execute_latency_ms', TType::DOUBLE, 1);
      $xfer += $output->writeDouble($this->execute_latency_ms);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->process_latency_ms !== null) {
      $xfer += $output->writeFieldBegin('process_latency_ms', TType::DOUBLE, 2);
      $xfer += $output->writeDouble($this->process_latency_ms);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->executed !== null) {
      $xfer += $output->writeFieldBegin('executed', TType::I64, 3);
      $xfer += $output->writeI64($this->executed);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->capacity !== null) {
      $xfer += $output->writeFieldBegin('capacity', TType::DOUBLE, 4);
      $xfer += $output->writeDouble($this->capacity);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SpecificAggregateStats {
  static $_TSPEC;

  /**
   * @var \topology\BoltAggregateStats
   */
  public $bolt = null;
  /**
   * @var \topology\SpoutAggregateStats
   */
  public $spout = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'bolt',
          'type' => TType::STRUCT,
          'class' => '\topology\BoltAggregateStats',
          ),
        2 => array(
          'var' => 'spout',
          'type' => TType::STRUCT,
          'class' => '\topology\SpoutAggregateStats',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['bolt'])) {
        $this->bolt = $vals['bolt'];
      }
      if (isset($vals['spout'])) {
        $this->spout = $vals['spout'];
      }
    }
  }

  public function getName() {
    return 'SpecificAggregateStats';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->bolt = new \topology\BoltAggregateStats();
            $xfer += $this->bolt->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->spout = new \topology\SpoutAggregateStats();
            $xfer += $this->spout->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SpecificAggregateStats');
    if ($this->bolt !== null) {
      if (!is_object($this->bolt)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('bolt', TType::STRUCT, 1);
      $xfer += $this->bolt->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->spout !== null) {
      if (!is_object($this->spout)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('spout', TType::STRUCT, 2);
      $xfer += $this->spout->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ComponentAggregateStats {
  static $_TSPEC;

  /**
   * @var int
   */
  public $type = null;
  /**
   * @var \topology\CommonAggregateStats
   */
  public $common_stats = null;
  /**
   * @var \topology\SpecificAggregateStats
   */
  public $specific_stats = null;
  /**
   * @var \topology\ErrorInfo
   */
  public $last_error = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'type',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'common_stats',
          'type' => TType::STRUCT,
          'class' => '\topology\CommonAggregateStats',
          ),
        3 => array(
          'var' => 'specific_stats',
          'type' => TType::STRUCT,
          'class' => '\topology\SpecificAggregateStats',
          ),
        4 => array(
          'var' => 'last_error',
          'type' => TType::STRUCT,
          'class' => '\topology\ErrorInfo',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
      if (isset($vals['common_stats'])) {
        $this->common_stats = $vals['common_stats'];
      }
      if (isset($vals['specific_stats'])) {
        $this->specific_stats = $vals['specific_stats'];
      }
      if (isset($vals['last_error'])) {
        $this->last_error = $vals['last_error'];
      }
    }
  }

  public function getName() {
    return 'ComponentAggregateStats';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->common_stats = new \topology\CommonAggregateStats();
            $xfer += $this->common_stats->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->specific_stats = new \topology\SpecificAggregateStats();
            $xfer += $this->specific_stats->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->last_error = new \topology\ErrorInfo();
            $xfer += $this->last_error->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ComponentAggregateStats');
    if ($this->type !== null) {
      $xfer += $output->writeFieldBegin('type', TType::I32, 1);
      $xfer += $output->writeI32($this->type);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->common_stats !== null) {
      if (!is_object($this->common_stats)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('common_stats', TType::STRUCT, 2);
      $xfer += $this->common_stats->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->specific_stats !== null) {
      if (!is_object($this->specific_stats)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('specific_stats', TType::STRUCT, 3);
      $xfer += $this->specific_stats->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->last_error !== null) {
      if (!is_object($this->last_error)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('last_error', TType::STRUCT, 4);
      $xfer += $this->last_error->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TopologyStats {
  static $_TSPEC;

  /**
   * @var array
   */
  public $window_to_emitted = null;
  /**
   * @var array
   */
  public $window_to_transferred = null;
  /**
   * @var array
   */
  public $window_to_complete_latencies_ms = null;
  /**
   * @var array
   */
  public $window_to_acked = null;
  /**
   * @var array
   */
  public $window_to_failed = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'window_to_emitted',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::I64,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::I64,
            ),
          ),
        2 => array(
          'var' => 'window_to_transferred',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::I64,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::I64,
            ),
          ),
        3 => array(
          'var' => 'window_to_complete_latencies_ms',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::DOUBLE,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::DOUBLE,
            ),
          ),
        4 => array(
          'var' => 'window_to_acked',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::I64,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::I64,
            ),
          ),
        5 => array(
          'var' => 'window_to_failed',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::I64,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::I64,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['window_to_emitted'])) {
        $this->window_to_emitted = $vals['window_to_emitted'];
      }
      if (isset($vals['window_to_transferred'])) {
        $this->window_to_transferred = $vals['window_to_transferred'];
      }
      if (isset($vals['window_to_complete_latencies_ms'])) {
        $this->window_to_complete_latencies_ms = $vals['window_to_complete_latencies_ms'];
      }
      if (isset($vals['window_to_acked'])) {
        $this->window_to_acked = $vals['window_to_acked'];
      }
      if (isset($vals['window_to_failed'])) {
        $this->window_to_failed = $vals['window_to_failed'];
      }
    }
  }

  public function getName() {
    return 'TopologyStats';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->window_to_emitted = array();
            $_size338 = 0;
            $_ktype339 = 0;
            $_vtype340 = 0;
            $xfer += $input->readMapBegin($_ktype339, $_vtype340, $_size338);
            for ($_i342 = 0; $_i342 < $_size338; ++$_i342)
            {
              $key343 = '';
              $val344 = 0;
              $xfer += $input->readString($key343);
              $xfer += $input->readI64($val344);
              $this->window_to_emitted[$key343] = $val344;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::MAP) {
            $this->window_to_transferred = array();
            $_size345 = 0;
            $_ktype346 = 0;
            $_vtype347 = 0;
            $xfer += $input->readMapBegin($_ktype346, $_vtype347, $_size345);
            for ($_i349 = 0; $_i349 < $_size345; ++$_i349)
            {
              $key350 = '';
              $val351 = 0;
              $xfer += $input->readString($key350);
              $xfer += $input->readI64($val351);
              $this->window_to_transferred[$key350] = $val351;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::MAP) {
            $this->window_to_complete_latencies_ms = array();
            $_size352 = 0;
            $_ktype353 = 0;
            $_vtype354 = 0;
            $xfer += $input->readMapBegin($_ktype353, $_vtype354, $_size352);
            for ($_i356 = 0; $_i356 < $_size352; ++$_i356)
            {
              $key357 = '';
              $val358 = 0.0;
              $xfer += $input->readString($key357);
              $xfer += $input->readDouble($val358);
              $this->window_to_complete_latencies_ms[$key357] = $val358;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::MAP) {
            $this->window_to_acked = array();
            $_size359 = 0;
            $_ktype360 = 0;
            $_vtype361 = 0;
            $xfer += $input->readMapBegin($_ktype360, $_vtype361, $_size359);
            for ($_i363 = 0; $_i363 < $_size359; ++$_i363)
            {
              $key364 = '';
              $val365 = 0;
              $xfer += $input->readString($key364);
              $xfer += $input->readI64($val365);
              $this->window_to_acked[$key364] = $val365;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::MAP) {
            $this->window_to_failed = array();
            $_size366 = 0;
            $_ktype367 = 0;
            $_vtype368 = 0;
            $xfer += $input->readMapBegin($_ktype367, $_vtype368, $_size366);
            for ($_i370 = 0; $_i370 < $_size366; ++$_i370)
            {
              $key371 = '';
              $val372 = 0;
              $xfer += $input->readString($key371);
              $xfer += $input->readI64($val372);
              $this->window_to_failed[$key371] = $val372;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TopologyStats');
    if ($this->window_to_emitted !== null) {
      if (!is_array($this->window_to_emitted)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('window_to_emitted', TType::MAP, 1);
      {
        $output->writeMapBegin(TType::STRING, TType::I64, count($this->window_to_emitted));
        {
          foreach ($this->window_to_emitted as $kiter373 => $viter374)
          {
            $xfer += $output->writeString($kiter373);
            $xfer += $output->writeI64($viter374);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->window_to_transferred !== null) {
      if (!is_array($this->window_to_transferred)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('window_to_transferred', TType::MAP, 2);
      {
        $output->writeMapBegin(TType::STRING, TType::I64, count($this->window_to_transferred));
        {
          foreach ($this->window_to_transferred as $kiter375 => $viter376)
          {
            $xfer += $output->writeString($kiter375);
            $xfer += $output->writeI64($viter376);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->window_to_complete_latencies_ms !== null) {
      if (!is_array($this->window_to_complete_latencies_ms)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('window_to_complete_latencies_ms', TType::MAP, 3);
      {
        $output->writeMapBegin(TType::STRING, TType::DOUBLE, count($this->window_to_complete_latencies_ms));
        {
          foreach ($this->window_to_complete_latencies_ms as $kiter377 => $viter378)
          {
            $xfer += $output->writeString($kiter377);
            $xfer += $output->writeDouble($viter378);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->window_to_acked !== null) {
      if (!is_array($this->window_to_acked)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('window_to_acked', TType::MAP, 4);
      {
        $output->writeMapBegin(TType::STRING, TType::I64, count($this->window_to_acked));
        {
          foreach ($this->window_to_acked as $kiter379 => $viter380)
          {
            $xfer += $output->writeString($kiter379);
            $xfer += $output->writeI64($viter380);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->window_to_failed !== null) {
      if (!is_array($this->window_to_failed)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('window_to_failed', TType::MAP, 5);
      {
        $output->writeMapBegin(TType::STRING, TType::I64, count($this->window_to_failed));
        {
          foreach ($this->window_to_failed as $kiter381 => $viter382)
          {
            $xfer += $output->writeString($kiter381);
            $xfer += $output->writeI64($viter382);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class WorkerSummary {
  static $_TSPEC;

  /**
   * @var string
   */
  public $supervisor_id = null;
  /**
   * @var string
   */
  public $host = null;
  /**
   * @var int
   */
  public $port = null;
  /**
   * @var string
   */
  public $topology_id = null;
  /**
   * @var string
   */
  public $topology_name = null;
  /**
   * @var int
   */
  public $num_executors = null;
  /**
   * @var array
   */
  public $component_to_num_tasks = null;
  /**
   * @var int
   */
  public $time_secs = null;
  /**
   * @var int
   */
  public $uptime_secs = null;
  /**
   * @var double
   */
  public $requested_memonheap = null;
  /**
   * @var double
   */
  public $requested_memoffheap = null;
  /**
   * @var double
   */
  public $requested_cpu = null;
  /**
   * @var double
   */
  public $assigned_memonheap = null;
  /**
   * @var double
   */
  public $assigned_memoffheap = null;
  /**
   * @var double
   */
  public $assigned_cpu = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'supervisor_id',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'host',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'port',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'topology_id',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'topology_name',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'num_executors',
          'type' => TType::I32,
          ),
        7 => array(
          'var' => 'component_to_num_tasks',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::I64,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::I64,
            ),
          ),
        8 => array(
          'var' => 'time_secs',
          'type' => TType::I32,
          ),
        9 => array(
          'var' => 'uptime_secs',
          'type' => TType::I32,
          ),
        521 => array(
          'var' => 'requested_memonheap',
          'type' => TType::DOUBLE,
          ),
        522 => array(
          'var' => 'requested_memoffheap',
          'type' => TType::DOUBLE,
          ),
        523 => array(
          'var' => 'requested_cpu',
          'type' => TType::DOUBLE,
          ),
        524 => array(
          'var' => 'assigned_memonheap',
          'type' => TType::DOUBLE,
          ),
        525 => array(
          'var' => 'assigned_memoffheap',
          'type' => TType::DOUBLE,
          ),
        526 => array(
          'var' => 'assigned_cpu',
          'type' => TType::DOUBLE,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['supervisor_id'])) {
        $this->supervisor_id = $vals['supervisor_id'];
      }
      if (isset($vals['host'])) {
        $this->host = $vals['host'];
      }
      if (isset($vals['port'])) {
        $this->port = $vals['port'];
      }
      if (isset($vals['topology_id'])) {
        $this->topology_id = $vals['topology_id'];
      }
      if (isset($vals['topology_name'])) {
        $this->topology_name = $vals['topology_name'];
      }
      if (isset($vals['num_executors'])) {
        $this->num_executors = $vals['num_executors'];
      }
      if (isset($vals['component_to_num_tasks'])) {
        $this->component_to_num_tasks = $vals['component_to_num_tasks'];
      }
      if (isset($vals['time_secs'])) {
        $this->time_secs = $vals['time_secs'];
      }
      if (isset($vals['uptime_secs'])) {
        $this->uptime_secs = $vals['uptime_secs'];
      }
      if (isset($vals['requested_memonheap'])) {
        $this->requested_memonheap = $vals['requested_memonheap'];
      }
      if (isset($vals['requested_memoffheap'])) {
        $this->requested_memoffheap = $vals['requested_memoffheap'];
      }
      if (isset($vals['requested_cpu'])) {
        $this->requested_cpu = $vals['requested_cpu'];
      }
      if (isset($vals['assigned_memonheap'])) {
        $this->assigned_memonheap = $vals['assigned_memonheap'];
      }
      if (isset($vals['assigned_memoffheap'])) {
        $this->assigned_memoffheap = $vals['assigned_memoffheap'];
      }
      if (isset($vals['assigned_cpu'])) {
        $this->assigned_cpu = $vals['assigned_cpu'];
      }
    }
  }

  public function getName() {
    return 'WorkerSummary';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->supervisor_id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->host);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->port);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->topology_id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->topology_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->num_executors);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::MAP) {
            $this->component_to_num_tasks = array();
            $_size383 = 0;
            $_ktype384 = 0;
            $_vtype385 = 0;
            $xfer += $input->readMapBegin($_ktype384, $_vtype385, $_size383);
            for ($_i387 = 0; $_i387 < $_size383; ++$_i387)
            {
              $key388 = '';
              $val389 = 0;
              $xfer += $input->readString($key388);
              $xfer += $input->readI64($val389);
              $this->component_to_num_tasks[$key388] = $val389;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->time_secs);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->uptime_secs);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 521:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->requested_memonheap);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 522:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->requested_memoffheap);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 523:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->requested_cpu);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 524:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->assigned_memonheap);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 525:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->assigned_memoffheap);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 526:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->assigned_cpu);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WorkerSummary');
    if ($this->supervisor_id !== null) {
      $xfer += $output->writeFieldBegin('supervisor_id', TType::STRING, 1);
      $xfer += $output->writeString($this->supervisor_id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->host !== null) {
      $xfer += $output->writeFieldBegin('host', TType::STRING, 2);
      $xfer += $output->writeString($this->host);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->port !== null) {
      $xfer += $output->writeFieldBegin('port', TType::I32, 3);
      $xfer += $output->writeI32($this->port);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->topology_id !== null) {
      $xfer += $output->writeFieldBegin('topology_id', TType::STRING, 4);
      $xfer += $output->writeString($this->topology_id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->topology_name !== null) {
      $xfer += $output->writeFieldBegin('topology_name', TType::STRING, 5);
      $xfer += $output->writeString($this->topology_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->num_executors !== null) {
      $xfer += $output->writeFieldBegin('num_executors', TType::I32, 6);
      $xfer += $output->writeI32($this->num_executors);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->component_to_num_tasks !== null) {
      if (!is_array($this->component_to_num_tasks)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('component_to_num_tasks', TType::MAP, 7);
      {
        $output->writeMapBegin(TType::STRING, TType::I64, count($this->component_to_num_tasks));
        {
          foreach ($this->component_to_num_tasks as $kiter390 => $viter391)
          {
            $xfer += $output->writeString($kiter390);
            $xfer += $output->writeI64($viter391);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->time_secs !== null) {
      $xfer += $output->writeFieldBegin('time_secs', TType::I32, 8);
      $xfer += $output->writeI32($this->time_secs);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->uptime_secs !== null) {
      $xfer += $output->writeFieldBegin('uptime_secs', TType::I32, 9);
      $xfer += $output->writeI32($this->uptime_secs);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->requested_memonheap !== null) {
      $xfer += $output->writeFieldBegin('requested_memonheap', TType::DOUBLE, 521);
      $xfer += $output->writeDouble($this->requested_memonheap);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->requested_memoffheap !== null) {
      $xfer += $output->writeFieldBegin('requested_memoffheap', TType::DOUBLE, 522);
      $xfer += $output->writeDouble($this->requested_memoffheap);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->requested_cpu !== null) {
      $xfer += $output->writeFieldBegin('requested_cpu', TType::DOUBLE, 523);
      $xfer += $output->writeDouble($this->requested_cpu);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->assigned_memonheap !== null) {
      $xfer += $output->writeFieldBegin('assigned_memonheap', TType::DOUBLE, 524);
      $xfer += $output->writeDouble($this->assigned_memonheap);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->assigned_memoffheap !== null) {
      $xfer += $output->writeFieldBegin('assigned_memoffheap', TType::DOUBLE, 525);
      $xfer += $output->writeDouble($this->assigned_memoffheap);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->assigned_cpu !== null) {
      $xfer += $output->writeFieldBegin('assigned_cpu', TType::DOUBLE, 526);
      $xfer += $output->writeDouble($this->assigned_cpu);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SupervisorPageInfo {
  static $_TSPEC;

  /**
   * @var \topology\SupervisorSummary[]
   */
  public $supervisor_summaries = null;
  /**
   * @var \topology\WorkerSummary[]
   */
  public $worker_summaries = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'supervisor_summaries',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\topology\SupervisorSummary',
            ),
          ),
        2 => array(
          'var' => 'worker_summaries',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\topology\WorkerSummary',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['supervisor_summaries'])) {
        $this->supervisor_summaries = $vals['supervisor_summaries'];
      }
      if (isset($vals['worker_summaries'])) {
        $this->worker_summaries = $vals['worker_summaries'];
      }
    }
  }

  public function getName() {
    return 'SupervisorPageInfo';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->supervisor_summaries = array();
            $_size392 = 0;
            $_etype395 = 0;
            $xfer += $input->readListBegin($_etype395, $_size392);
            for ($_i396 = 0; $_i396 < $_size392; ++$_i396)
            {
              $elem397 = null;
              $elem397 = new \topology\SupervisorSummary();
              $xfer += $elem397->read($input);
              $this->supervisor_summaries []= $elem397;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->worker_summaries = array();
            $_size398 = 0;
            $_etype401 = 0;
            $xfer += $input->readListBegin($_etype401, $_size398);
            for ($_i402 = 0; $_i402 < $_size398; ++$_i402)
            {
              $elem403 = null;
              $elem403 = new \topology\WorkerSummary();
              $xfer += $elem403->read($input);
              $this->worker_summaries []= $elem403;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SupervisorPageInfo');
    if ($this->supervisor_summaries !== null) {
      if (!is_array($this->supervisor_summaries)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('supervisor_summaries', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->supervisor_summaries));
        {
          foreach ($this->supervisor_summaries as $iter404)
          {
            $xfer += $iter404->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->worker_summaries !== null) {
      if (!is_array($this->worker_summaries)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('worker_summaries', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->worker_summaries));
        {
          foreach ($this->worker_summaries as $iter405)
          {
            $xfer += $iter405->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TopologyPageInfo {
  static $_TSPEC;

  /**
   * @var string
   */
  public $id = null;
  /**
   * @var string
   */
  public $name = null;
  /**
   * @var int
   */
  public $uptime_secs = null;
  /**
   * @var string
   */
  public $status = null;
  /**
   * @var int
   */
  public $num_tasks = null;
  /**
   * @var int
   */
  public $num_workers = null;
  /**
   * @var int
   */
  public $num_executors = null;
  /**
   * @var string
   */
  public $topology_conf = null;
  /**
   * @var array
   */
  public $id_to_spout_agg_stats = null;
  /**
   * @var array
   */
  public $id_to_bolt_agg_stats = null;
  /**
   * @var string
   */
  public $sched_status = null;
  /**
   * @var \topology\TopologyStats
   */
  public $topology_stats = null;
  /**
   * @var string
   */
  public $owner = null;
  /**
   * @var \topology\DebugOptions
   */
  public $debug_options = null;
  /**
   * @var int
   */
  public $replication_count = null;
  /**
   * @var \topology\WorkerSummary[]
   */
  public $workers = null;
  /**
   * @var double
   */
  public $requested_memonheap = null;
  /**
   * @var double
   */
  public $requested_memoffheap = null;
  /**
   * @var double
   */
  public $requested_cpu = null;
  /**
   * @var double
   */
  public $assigned_memonheap = null;
  /**
   * @var double
   */
  public $assigned_memoffheap = null;
  /**
   * @var double
   */
  public $assigned_cpu = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'id',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'uptime_secs',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'status',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'num_tasks',
          'type' => TType::I32,
          ),
        6 => array(
          'var' => 'num_workers',
          'type' => TType::I32,
          ),
        7 => array(
          'var' => 'num_executors',
          'type' => TType::I32,
          ),
        8 => array(
          'var' => 'topology_conf',
          'type' => TType::STRING,
          ),
        9 => array(
          'var' => 'id_to_spout_agg_stats',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRUCT,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRUCT,
            'class' => '\topology\ComponentAggregateStats',
            ),
          ),
        10 => array(
          'var' => 'id_to_bolt_agg_stats',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRUCT,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRUCT,
            'class' => '\topology\ComponentAggregateStats',
            ),
          ),
        11 => array(
          'var' => 'sched_status',
          'type' => TType::STRING,
          ),
        12 => array(
          'var' => 'topology_stats',
          'type' => TType::STRUCT,
          'class' => '\topology\TopologyStats',
          ),
        13 => array(
          'var' => 'owner',
          'type' => TType::STRING,
          ),
        14 => array(
          'var' => 'debug_options',
          'type' => TType::STRUCT,
          'class' => '\topology\DebugOptions',
          ),
        15 => array(
          'var' => 'replication_count',
          'type' => TType::I32,
          ),
        16 => array(
          'var' => 'workers',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\topology\WorkerSummary',
            ),
          ),
        521 => array(
          'var' => 'requested_memonheap',
          'type' => TType::DOUBLE,
          ),
        522 => array(
          'var' => 'requested_memoffheap',
          'type' => TType::DOUBLE,
          ),
        523 => array(
          'var' => 'requested_cpu',
          'type' => TType::DOUBLE,
          ),
        524 => array(
          'var' => 'assigned_memonheap',
          'type' => TType::DOUBLE,
          ),
        525 => array(
          'var' => 'assigned_memoffheap',
          'type' => TType::DOUBLE,
          ),
        526 => array(
          'var' => 'assigned_cpu',
          'type' => TType::DOUBLE,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['id'])) {
        $this->id = $vals['id'];
      }
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['uptime_secs'])) {
        $this->uptime_secs = $vals['uptime_secs'];
      }
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
      if (isset($vals['num_tasks'])) {
        $this->num_tasks = $vals['num_tasks'];
      }
      if (isset($vals['num_workers'])) {
        $this->num_workers = $vals['num_workers'];
      }
      if (isset($vals['num_executors'])) {
        $this->num_executors = $vals['num_executors'];
      }
      if (isset($vals['topology_conf'])) {
        $this->topology_conf = $vals['topology_conf'];
      }
      if (isset($vals['id_to_spout_agg_stats'])) {
        $this->id_to_spout_agg_stats = $vals['id_to_spout_agg_stats'];
      }
      if (isset($vals['id_to_bolt_agg_stats'])) {
        $this->id_to_bolt_agg_stats = $vals['id_to_bolt_agg_stats'];
      }
      if (isset($vals['sched_status'])) {
        $this->sched_status = $vals['sched_status'];
      }
      if (isset($vals['topology_stats'])) {
        $this->topology_stats = $vals['topology_stats'];
      }
      if (isset($vals['owner'])) {
        $this->owner = $vals['owner'];
      }
      if (isset($vals['debug_options'])) {
        $this->debug_options = $vals['debug_options'];
      }
      if (isset($vals['replication_count'])) {
        $this->replication_count = $vals['replication_count'];
      }
      if (isset($vals['workers'])) {
        $this->workers = $vals['workers'];
      }
      if (isset($vals['requested_memonheap'])) {
        $this->requested_memonheap = $vals['requested_memonheap'];
      }
      if (isset($vals['requested_memoffheap'])) {
        $this->requested_memoffheap = $vals['requested_memoffheap'];
      }
      if (isset($vals['requested_cpu'])) {
        $this->requested_cpu = $vals['requested_cpu'];
      }
      if (isset($vals['assigned_memonheap'])) {
        $this->assigned_memonheap = $vals['assigned_memonheap'];
      }
      if (isset($vals['assigned_memoffheap'])) {
        $this->assigned_memoffheap = $vals['assigned_memoffheap'];
      }
      if (isset($vals['assigned_cpu'])) {
        $this->assigned_cpu = $vals['assigned_cpu'];
      }
    }
  }

  public function getName() {
    return 'TopologyPageInfo';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->uptime_secs);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->status);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->num_tasks);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->num_workers);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->num_executors);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->topology_conf);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::MAP) {
            $this->id_to_spout_agg_stats = array();
            $_size406 = 0;
            $_ktype407 = 0;
            $_vtype408 = 0;
            $xfer += $input->readMapBegin($_ktype407, $_vtype408, $_size406);
            for ($_i410 = 0; $_i410 < $_size406; ++$_i410)
            {
              $key411 = '';
              $val412 = new \topology\ComponentAggregateStats();
              $xfer += $input->readString($key411);
              $val412 = new \topology\ComponentAggregateStats();
              $xfer += $val412->read($input);
              $this->id_to_spout_agg_stats[$key411] = $val412;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::MAP) {
            $this->id_to_bolt_agg_stats = array();
            $_size413 = 0;
            $_ktype414 = 0;
            $_vtype415 = 0;
            $xfer += $input->readMapBegin($_ktype414, $_vtype415, $_size413);
            for ($_i417 = 0; $_i417 < $_size413; ++$_i417)
            {
              $key418 = '';
              $val419 = new \topology\ComponentAggregateStats();
              $xfer += $input->readString($key418);
              $val419 = new \topology\ComponentAggregateStats();
              $xfer += $val419->read($input);
              $this->id_to_bolt_agg_stats[$key418] = $val419;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 11:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->sched_status);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 12:
          if ($ftype == TType::STRUCT) {
            $this->topology_stats = new \topology\TopologyStats();
            $xfer += $this->topology_stats->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 13:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->owner);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 14:
          if ($ftype == TType::STRUCT) {
            $this->debug_options = new \topology\DebugOptions();
            $xfer += $this->debug_options->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 15:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->replication_count);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 16:
          if ($ftype == TType::LST) {
            $this->workers = array();
            $_size420 = 0;
            $_etype423 = 0;
            $xfer += $input->readListBegin($_etype423, $_size420);
            for ($_i424 = 0; $_i424 < $_size420; ++$_i424)
            {
              $elem425 = null;
              $elem425 = new \topology\WorkerSummary();
              $xfer += $elem425->read($input);
              $this->workers []= $elem425;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 521:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->requested_memonheap);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 522:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->requested_memoffheap);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 523:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->requested_cpu);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 524:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->assigned_memonheap);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 525:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->assigned_memoffheap);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 526:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->assigned_cpu);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TopologyPageInfo');
    if ($this->id !== null) {
      $xfer += $output->writeFieldBegin('id', TType::STRING, 1);
      $xfer += $output->writeString($this->id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 2);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->uptime_secs !== null) {
      $xfer += $output->writeFieldBegin('uptime_secs', TType::I32, 3);
      $xfer += $output->writeI32($this->uptime_secs);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->status !== null) {
      $xfer += $output->writeFieldBegin('status', TType::STRING, 4);
      $xfer += $output->writeString($this->status);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->num_tasks !== null) {
      $xfer += $output->writeFieldBegin('num_tasks', TType::I32, 5);
      $xfer += $output->writeI32($this->num_tasks);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->num_workers !== null) {
      $xfer += $output->writeFieldBegin('num_workers', TType::I32, 6);
      $xfer += $output->writeI32($this->num_workers);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->num_executors !== null) {
      $xfer += $output->writeFieldBegin('num_executors', TType::I32, 7);
      $xfer += $output->writeI32($this->num_executors);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->topology_conf !== null) {
      $xfer += $output->writeFieldBegin('topology_conf', TType::STRING, 8);
      $xfer += $output->writeString($this->topology_conf);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->id_to_spout_agg_stats !== null) {
      if (!is_array($this->id_to_spout_agg_stats)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('id_to_spout_agg_stats', TType::MAP, 9);
      {
        $output->writeMapBegin(TType::STRING, TType::STRUCT, count($this->id_to_spout_agg_stats));
        {
          foreach ($this->id_to_spout_agg_stats as $kiter426 => $viter427)
          {
            $xfer += $output->writeString($kiter426);
            $xfer += $viter427->write($output);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->id_to_bolt_agg_stats !== null) {
      if (!is_array($this->id_to_bolt_agg_stats)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('id_to_bolt_agg_stats', TType::MAP, 10);
      {
        $output->writeMapBegin(TType::STRING, TType::STRUCT, count($this->id_to_bolt_agg_stats));
        {
          foreach ($this->id_to_bolt_agg_stats as $kiter428 => $viter429)
          {
            $xfer += $output->writeString($kiter428);
            $xfer += $viter429->write($output);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->sched_status !== null) {
      $xfer += $output->writeFieldBegin('sched_status', TType::STRING, 11);
      $xfer += $output->writeString($this->sched_status);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->topology_stats !== null) {
      if (!is_object($this->topology_stats)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('topology_stats', TType::STRUCT, 12);
      $xfer += $this->topology_stats->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->owner !== null) {
      $xfer += $output->writeFieldBegin('owner', TType::STRING, 13);
      $xfer += $output->writeString($this->owner);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->debug_options !== null) {
      if (!is_object($this->debug_options)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('debug_options', TType::STRUCT, 14);
      $xfer += $this->debug_options->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->replication_count !== null) {
      $xfer += $output->writeFieldBegin('replication_count', TType::I32, 15);
      $xfer += $output->writeI32($this->replication_count);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->workers !== null) {
      if (!is_array($this->workers)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('workers', TType::LST, 16);
      {
        $output->writeListBegin(TType::STRUCT, count($this->workers));
        {
          foreach ($this->workers as $iter430)
          {
            $xfer += $iter430->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->requested_memonheap !== null) {
      $xfer += $output->writeFieldBegin('requested_memonheap', TType::DOUBLE, 521);
      $xfer += $output->writeDouble($this->requested_memonheap);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->requested_memoffheap !== null) {
      $xfer += $output->writeFieldBegin('requested_memoffheap', TType::DOUBLE, 522);
      $xfer += $output->writeDouble($this->requested_memoffheap);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->requested_cpu !== null) {
      $xfer += $output->writeFieldBegin('requested_cpu', TType::DOUBLE, 523);
      $xfer += $output->writeDouble($this->requested_cpu);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->assigned_memonheap !== null) {
      $xfer += $output->writeFieldBegin('assigned_memonheap', TType::DOUBLE, 524);
      $xfer += $output->writeDouble($this->assigned_memonheap);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->assigned_memoffheap !== null) {
      $xfer += $output->writeFieldBegin('assigned_memoffheap', TType::DOUBLE, 525);
      $xfer += $output->writeDouble($this->assigned_memoffheap);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->assigned_cpu !== null) {
      $xfer += $output->writeFieldBegin('assigned_cpu', TType::DOUBLE, 526);
      $xfer += $output->writeDouble($this->assigned_cpu);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ExecutorAggregateStats {
  static $_TSPEC;

  /**
   * @var \topology\ExecutorSummary
   */
  public $exec_summary = null;
  /**
   * @var \topology\ComponentAggregateStats
   */
  public $stats = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'exec_summary',
          'type' => TType::STRUCT,
          'class' => '\topology\ExecutorSummary',
          ),
        2 => array(
          'var' => 'stats',
          'type' => TType::STRUCT,
          'class' => '\topology\ComponentAggregateStats',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['exec_summary'])) {
        $this->exec_summary = $vals['exec_summary'];
      }
      if (isset($vals['stats'])) {
        $this->stats = $vals['stats'];
      }
    }
  }

  public function getName() {
    return 'ExecutorAggregateStats';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->exec_summary = new \topology\ExecutorSummary();
            $xfer += $this->exec_summary->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->stats = new \topology\ComponentAggregateStats();
            $xfer += $this->stats->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ExecutorAggregateStats');
    if ($this->exec_summary !== null) {
      if (!is_object($this->exec_summary)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('exec_summary', TType::STRUCT, 1);
      $xfer += $this->exec_summary->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->stats !== null) {
      if (!is_object($this->stats)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('stats', TType::STRUCT, 2);
      $xfer += $this->stats->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ComponentPageInfo {
  static $_TSPEC;

  /**
   * @var string
   */
  public $component_id = null;
  /**
   * @var int
   */
  public $component_type = null;
  /**
   * @var string
   */
  public $topology_id = null;
  /**
   * @var string
   */
  public $topology_name = null;
  /**
   * @var int
   */
  public $num_executors = null;
  /**
   * @var int
   */
  public $num_tasks = null;
  /**
   * @var array
   */
  public $window_to_stats = null;
  /**
   * @var array
   */
  public $gsid_to_input_stats = null;
  /**
   * @var array
   */
  public $sid_to_output_stats = null;
  /**
   * @var \topology\ExecutorAggregateStats[]
   */
  public $exec_stats = null;
  /**
   * @var \topology\ErrorInfo[]
   */
  public $errors = null;
  /**
   * @var string
   */
  public $eventlog_host = null;
  /**
   * @var int
   */
  public $eventlog_port = null;
  /**
   * @var \topology\DebugOptions
   */
  public $debug_options = null;
  /**
   * @var string
   */
  public $topology_status = null;
  /**
   * @var array
   */
  public $resources_map = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'component_id',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'component_type',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'topology_id',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'topology_name',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'num_executors',
          'type' => TType::I32,
          ),
        6 => array(
          'var' => 'num_tasks',
          'type' => TType::I32,
          ),
        7 => array(
          'var' => 'window_to_stats',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRUCT,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRUCT,
            'class' => '\topology\ComponentAggregateStats',
            ),
          ),
        8 => array(
          'var' => 'gsid_to_input_stats',
          'type' => TType::MAP,
          'ktype' => TType::STRUCT,
          'vtype' => TType::STRUCT,
          'key' => array(
            'type' => TType::STRUCT,
            'class' => '\topology\GlobalStreamId',
          ),
          'val' => array(
            'type' => TType::STRUCT,
            'class' => '\topology\ComponentAggregateStats',
            ),
          ),
        9 => array(
          'var' => 'sid_to_output_stats',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRUCT,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRUCT,
            'class' => '\topology\ComponentAggregateStats',
            ),
          ),
        10 => array(
          'var' => 'exec_stats',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\topology\ExecutorAggregateStats',
            ),
          ),
        11 => array(
          'var' => 'errors',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\topology\ErrorInfo',
            ),
          ),
        12 => array(
          'var' => 'eventlog_host',
          'type' => TType::STRING,
          ),
        13 => array(
          'var' => 'eventlog_port',
          'type' => TType::I32,
          ),
        14 => array(
          'var' => 'debug_options',
          'type' => TType::STRUCT,
          'class' => '\topology\DebugOptions',
          ),
        15 => array(
          'var' => 'topology_status',
          'type' => TType::STRING,
          ),
        16 => array(
          'var' => 'resources_map',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::DOUBLE,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::DOUBLE,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['component_id'])) {
        $this->component_id = $vals['component_id'];
      }
      if (isset($vals['component_type'])) {
        $this->component_type = $vals['component_type'];
      }
      if (isset($vals['topology_id'])) {
        $this->topology_id = $vals['topology_id'];
      }
      if (isset($vals['topology_name'])) {
        $this->topology_name = $vals['topology_name'];
      }
      if (isset($vals['num_executors'])) {
        $this->num_executors = $vals['num_executors'];
      }
      if (isset($vals['num_tasks'])) {
        $this->num_tasks = $vals['num_tasks'];
      }
      if (isset($vals['window_to_stats'])) {
        $this->window_to_stats = $vals['window_to_stats'];
      }
      if (isset($vals['gsid_to_input_stats'])) {
        $this->gsid_to_input_stats = $vals['gsid_to_input_stats'];
      }
      if (isset($vals['sid_to_output_stats'])) {
        $this->sid_to_output_stats = $vals['sid_to_output_stats'];
      }
      if (isset($vals['exec_stats'])) {
        $this->exec_stats = $vals['exec_stats'];
      }
      if (isset($vals['errors'])) {
        $this->errors = $vals['errors'];
      }
      if (isset($vals['eventlog_host'])) {
        $this->eventlog_host = $vals['eventlog_host'];
      }
      if (isset($vals['eventlog_port'])) {
        $this->eventlog_port = $vals['eventlog_port'];
      }
      if (isset($vals['debug_options'])) {
        $this->debug_options = $vals['debug_options'];
      }
      if (isset($vals['topology_status'])) {
        $this->topology_status = $vals['topology_status'];
      }
      if (isset($vals['resources_map'])) {
        $this->resources_map = $vals['resources_map'];
      }
    }
  }

  public function getName() {
    return 'ComponentPageInfo';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->component_id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->component_type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->topology_id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->topology_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->num_executors);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->num_tasks);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::MAP) {
            $this->window_to_stats = array();
            $_size431 = 0;
            $_ktype432 = 0;
            $_vtype433 = 0;
            $xfer += $input->readMapBegin($_ktype432, $_vtype433, $_size431);
            for ($_i435 = 0; $_i435 < $_size431; ++$_i435)
            {
              $key436 = '';
              $val437 = new \topology\ComponentAggregateStats();
              $xfer += $input->readString($key436);
              $val437 = new \topology\ComponentAggregateStats();
              $xfer += $val437->read($input);
              $this->window_to_stats[$key436] = $val437;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::MAP) {
            $this->gsid_to_input_stats = array();
            $_size438 = 0;
            $_ktype439 = 0;
            $_vtype440 = 0;
            $xfer += $input->readMapBegin($_ktype439, $_vtype440, $_size438);
            for ($_i442 = 0; $_i442 < $_size438; ++$_i442)
            {
              $key443 = new \topology\GlobalStreamId();
              $val444 = new \topology\ComponentAggregateStats();
              $key443 = new \topology\GlobalStreamId();
              $xfer += $key443->read($input);
              $val444 = new \topology\ComponentAggregateStats();
              $xfer += $val444->read($input);
              $this->gsid_to_input_stats[$key443] = $val444;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::MAP) {
            $this->sid_to_output_stats = array();
            $_size445 = 0;
            $_ktype446 = 0;
            $_vtype447 = 0;
            $xfer += $input->readMapBegin($_ktype446, $_vtype447, $_size445);
            for ($_i449 = 0; $_i449 < $_size445; ++$_i449)
            {
              $key450 = '';
              $val451 = new \topology\ComponentAggregateStats();
              $xfer += $input->readString($key450);
              $val451 = new \topology\ComponentAggregateStats();
              $xfer += $val451->read($input);
              $this->sid_to_output_stats[$key450] = $val451;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::LST) {
            $this->exec_stats = array();
            $_size452 = 0;
            $_etype455 = 0;
            $xfer += $input->readListBegin($_etype455, $_size452);
            for ($_i456 = 0; $_i456 < $_size452; ++$_i456)
            {
              $elem457 = null;
              $elem457 = new \topology\ExecutorAggregateStats();
              $xfer += $elem457->read($input);
              $this->exec_stats []= $elem457;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 11:
          if ($ftype == TType::LST) {
            $this->errors = array();
            $_size458 = 0;
            $_etype461 = 0;
            $xfer += $input->readListBegin($_etype461, $_size458);
            for ($_i462 = 0; $_i462 < $_size458; ++$_i462)
            {
              $elem463 = null;
              $elem463 = new \topology\ErrorInfo();
              $xfer += $elem463->read($input);
              $this->errors []= $elem463;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 12:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->eventlog_host);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 13:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->eventlog_port);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 14:
          if ($ftype == TType::STRUCT) {
            $this->debug_options = new \topology\DebugOptions();
            $xfer += $this->debug_options->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 15:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->topology_status);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 16:
          if ($ftype == TType::MAP) {
            $this->resources_map = array();
            $_size464 = 0;
            $_ktype465 = 0;
            $_vtype466 = 0;
            $xfer += $input->readMapBegin($_ktype465, $_vtype466, $_size464);
            for ($_i468 = 0; $_i468 < $_size464; ++$_i468)
            {
              $key469 = '';
              $val470 = 0.0;
              $xfer += $input->readString($key469);
              $xfer += $input->readDouble($val470);
              $this->resources_map[$key469] = $val470;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ComponentPageInfo');
    if ($this->component_id !== null) {
      $xfer += $output->writeFieldBegin('component_id', TType::STRING, 1);
      $xfer += $output->writeString($this->component_id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->component_type !== null) {
      $xfer += $output->writeFieldBegin('component_type', TType::I32, 2);
      $xfer += $output->writeI32($this->component_type);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->topology_id !== null) {
      $xfer += $output->writeFieldBegin('topology_id', TType::STRING, 3);
      $xfer += $output->writeString($this->topology_id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->topology_name !== null) {
      $xfer += $output->writeFieldBegin('topology_name', TType::STRING, 4);
      $xfer += $output->writeString($this->topology_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->num_executors !== null) {
      $xfer += $output->writeFieldBegin('num_executors', TType::I32, 5);
      $xfer += $output->writeI32($this->num_executors);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->num_tasks !== null) {
      $xfer += $output->writeFieldBegin('num_tasks', TType::I32, 6);
      $xfer += $output->writeI32($this->num_tasks);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->window_to_stats !== null) {
      if (!is_array($this->window_to_stats)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('window_to_stats', TType::MAP, 7);
      {
        $output->writeMapBegin(TType::STRING, TType::STRUCT, count($this->window_to_stats));
        {
          foreach ($this->window_to_stats as $kiter471 => $viter472)
          {
            $xfer += $output->writeString($kiter471);
            $xfer += $viter472->write($output);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->gsid_to_input_stats !== null) {
      if (!is_array($this->gsid_to_input_stats)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('gsid_to_input_stats', TType::MAP, 8);
      {
        $output->writeMapBegin(TType::STRUCT, TType::STRUCT, count($this->gsid_to_input_stats));
        {
          foreach ($this->gsid_to_input_stats as $kiter473 => $viter474)
          {
            $xfer += $kiter473->write($output);
            $xfer += $viter474->write($output);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->sid_to_output_stats !== null) {
      if (!is_array($this->sid_to_output_stats)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sid_to_output_stats', TType::MAP, 9);
      {
        $output->writeMapBegin(TType::STRING, TType::STRUCT, count($this->sid_to_output_stats));
        {
          foreach ($this->sid_to_output_stats as $kiter475 => $viter476)
          {
            $xfer += $output->writeString($kiter475);
            $xfer += $viter476->write($output);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->exec_stats !== null) {
      if (!is_array($this->exec_stats)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('exec_stats', TType::LST, 10);
      {
        $output->writeListBegin(TType::STRUCT, count($this->exec_stats));
        {
          foreach ($this->exec_stats as $iter477)
          {
            $xfer += $iter477->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->errors !== null) {
      if (!is_array($this->errors)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('errors', TType::LST, 11);
      {
        $output->writeListBegin(TType::STRUCT, count($this->errors));
        {
          foreach ($this->errors as $iter478)
          {
            $xfer += $iter478->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->eventlog_host !== null) {
      $xfer += $output->writeFieldBegin('eventlog_host', TType::STRING, 12);
      $xfer += $output->writeString($this->eventlog_host);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->eventlog_port !== null) {
      $xfer += $output->writeFieldBegin('eventlog_port', TType::I32, 13);
      $xfer += $output->writeI32($this->eventlog_port);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->debug_options !== null) {
      if (!is_object($this->debug_options)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('debug_options', TType::STRUCT, 14);
      $xfer += $this->debug_options->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->topology_status !== null) {
      $xfer += $output->writeFieldBegin('topology_status', TType::STRING, 15);
      $xfer += $output->writeString($this->topology_status);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->resources_map !== null) {
      if (!is_array($this->resources_map)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('resources_map', TType::MAP, 16);
      {
        $output->writeMapBegin(TType::STRING, TType::DOUBLE, count($this->resources_map));
        {
          foreach ($this->resources_map as $kiter479 => $viter480)
          {
            $xfer += $output->writeString($kiter479);
            $xfer += $output->writeDouble($viter480);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class KillOptions {
  static $_TSPEC;

  /**
   * @var int
   */
  public $wait_secs = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'wait_secs',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['wait_secs'])) {
        $this->wait_secs = $vals['wait_secs'];
      }
    }
  }

  public function getName() {
    return 'KillOptions';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->wait_secs);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('KillOptions');
    if ($this->wait_secs !== null) {
      $xfer += $output->writeFieldBegin('wait_secs', TType::I32, 1);
      $xfer += $output->writeI32($this->wait_secs);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class RebalanceOptions {
  static $_TSPEC;

  /**
   * @var int
   */
  public $wait_secs = null;
  /**
   * @var int
   */
  public $num_workers = null;
  /**
   * @var array
   */
  public $num_executors = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'wait_secs',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'num_workers',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'num_executors',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::I32,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::I32,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['wait_secs'])) {
        $this->wait_secs = $vals['wait_secs'];
      }
      if (isset($vals['num_workers'])) {
        $this->num_workers = $vals['num_workers'];
      }
      if (isset($vals['num_executors'])) {
        $this->num_executors = $vals['num_executors'];
      }
    }
  }

  public function getName() {
    return 'RebalanceOptions';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->wait_secs);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->num_workers);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::MAP) {
            $this->num_executors = array();
            $_size481 = 0;
            $_ktype482 = 0;
            $_vtype483 = 0;
            $xfer += $input->readMapBegin($_ktype482, $_vtype483, $_size481);
            for ($_i485 = 0; $_i485 < $_size481; ++$_i485)
            {
              $key486 = '';
              $val487 = 0;
              $xfer += $input->readString($key486);
              $xfer += $input->readI32($val487);
              $this->num_executors[$key486] = $val487;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('RebalanceOptions');
    if ($this->wait_secs !== null) {
      $xfer += $output->writeFieldBegin('wait_secs', TType::I32, 1);
      $xfer += $output->writeI32($this->wait_secs);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->num_workers !== null) {
      $xfer += $output->writeFieldBegin('num_workers', TType::I32, 2);
      $xfer += $output->writeI32($this->num_workers);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->num_executors !== null) {
      if (!is_array($this->num_executors)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('num_executors', TType::MAP, 3);
      {
        $output->writeMapBegin(TType::STRING, TType::I32, count($this->num_executors));
        {
          foreach ($this->num_executors as $kiter488 => $viter489)
          {
            $xfer += $output->writeString($kiter488);
            $xfer += $output->writeI32($viter489);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Credentials {
  static $_TSPEC;

  /**
   * @var array
   */
  public $creds = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'creds',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['creds'])) {
        $this->creds = $vals['creds'];
      }
    }
  }

  public function getName() {
    return 'Credentials';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->creds = array();
            $_size490 = 0;
            $_ktype491 = 0;
            $_vtype492 = 0;
            $xfer += $input->readMapBegin($_ktype491, $_vtype492, $_size490);
            for ($_i494 = 0; $_i494 < $_size490; ++$_i494)
            {
              $key495 = '';
              $val496 = '';
              $xfer += $input->readString($key495);
              $xfer += $input->readString($val496);
              $this->creds[$key495] = $val496;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Credentials');
    if ($this->creds !== null) {
      if (!is_array($this->creds)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('creds', TType::MAP, 1);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->creds));
        {
          foreach ($this->creds as $kiter497 => $viter498)
          {
            $xfer += $output->writeString($kiter497);
            $xfer += $output->writeString($viter498);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SubmitOptions {
  static $_TSPEC;

  /**
   * @var int
   */
  public $initial_status = null;
  /**
   * @var \topology\Credentials
   */
  public $creds = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'initial_status',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'creds',
          'type' => TType::STRUCT,
          'class' => '\topology\Credentials',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['initial_status'])) {
        $this->initial_status = $vals['initial_status'];
      }
      if (isset($vals['creds'])) {
        $this->creds = $vals['creds'];
      }
    }
  }

  public function getName() {
    return 'SubmitOptions';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->initial_status);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->creds = new \topology\Credentials();
            $xfer += $this->creds->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SubmitOptions');
    if ($this->initial_status !== null) {
      $xfer += $output->writeFieldBegin('initial_status', TType::I32, 1);
      $xfer += $output->writeI32($this->initial_status);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->creds !== null) {
      if (!is_object($this->creds)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('creds', TType::STRUCT, 2);
      $xfer += $this->creds->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class AccessControl {
  static $_TSPEC;

  /**
   * @var int
   */
  public $type = null;
  /**
   * @var string
   */
  public $name = null;
  /**
   * @var int
   */
  public $access = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'type',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'access',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['access'])) {
        $this->access = $vals['access'];
      }
    }
  }

  public function getName() {
    return 'AccessControl';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->access);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('AccessControl');
    if ($this->type !== null) {
      $xfer += $output->writeFieldBegin('type', TType::I32, 1);
      $xfer += $output->writeI32($this->type);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 2);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->access !== null) {
      $xfer += $output->writeFieldBegin('access', TType::I32, 3);
      $xfer += $output->writeI32($this->access);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SettableBlobMeta {
  static $_TSPEC;

  /**
   * @var \topology\AccessControl[]
   */
  public $acl = null;
  /**
   * @var int
   */
  public $replication_factor = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'acl',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\topology\AccessControl',
            ),
          ),
        2 => array(
          'var' => 'replication_factor',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['acl'])) {
        $this->acl = $vals['acl'];
      }
      if (isset($vals['replication_factor'])) {
        $this->replication_factor = $vals['replication_factor'];
      }
    }
  }

  public function getName() {
    return 'SettableBlobMeta';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->acl = array();
            $_size499 = 0;
            $_etype502 = 0;
            $xfer += $input->readListBegin($_etype502, $_size499);
            for ($_i503 = 0; $_i503 < $_size499; ++$_i503)
            {
              $elem504 = null;
              $elem504 = new \topology\AccessControl();
              $xfer += $elem504->read($input);
              $this->acl []= $elem504;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->replication_factor);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SettableBlobMeta');
    if ($this->acl !== null) {
      if (!is_array($this->acl)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('acl', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->acl));
        {
          foreach ($this->acl as $iter505)
          {
            $xfer += $iter505->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->replication_factor !== null) {
      $xfer += $output->writeFieldBegin('replication_factor', TType::I32, 2);
      $xfer += $output->writeI32($this->replication_factor);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ReadableBlobMeta {
  static $_TSPEC;

  /**
   * @var \topology\SettableBlobMeta
   */
  public $settable = null;
  /**
   * @var int
   */
  public $version = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'settable',
          'type' => TType::STRUCT,
          'class' => '\topology\SettableBlobMeta',
          ),
        2 => array(
          'var' => 'version',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['settable'])) {
        $this->settable = $vals['settable'];
      }
      if (isset($vals['version'])) {
        $this->version = $vals['version'];
      }
    }
  }

  public function getName() {
    return 'ReadableBlobMeta';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->settable = new \topology\SettableBlobMeta();
            $xfer += $this->settable->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->version);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ReadableBlobMeta');
    if ($this->settable !== null) {
      if (!is_object($this->settable)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('settable', TType::STRUCT, 1);
      $xfer += $this->settable->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->version !== null) {
      $xfer += $output->writeFieldBegin('version', TType::I64, 2);
      $xfer += $output->writeI64($this->version);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ListBlobsResult {
  static $_TSPEC;

  /**
   * @var string[]
   */
  public $keys = null;
  /**
   * @var string
   */
  public $session = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'keys',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        2 => array(
          'var' => 'session',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['keys'])) {
        $this->keys = $vals['keys'];
      }
      if (isset($vals['session'])) {
        $this->session = $vals['session'];
      }
    }
  }

  public function getName() {
    return 'ListBlobsResult';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->keys = array();
            $_size506 = 0;
            $_etype509 = 0;
            $xfer += $input->readListBegin($_etype509, $_size506);
            for ($_i510 = 0; $_i510 < $_size506; ++$_i510)
            {
              $elem511 = null;
              $xfer += $input->readString($elem511);
              $this->keys []= $elem511;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->session);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ListBlobsResult');
    if ($this->keys !== null) {
      if (!is_array($this->keys)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('keys', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRING, count($this->keys));
        {
          foreach ($this->keys as $iter512)
          {
            $xfer += $output->writeString($iter512);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->session !== null) {
      $xfer += $output->writeFieldBegin('session', TType::STRING, 2);
      $xfer += $output->writeString($this->session);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class BeginDownloadResult {
  static $_TSPEC;

  /**
   * @var int
   */
  public $version = null;
  /**
   * @var string
   */
  public $session = null;
  /**
   * @var int
   */
  public $data_size = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'version',
          'type' => TType::I64,
          ),
        2 => array(
          'var' => 'session',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'data_size',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['version'])) {
        $this->version = $vals['version'];
      }
      if (isset($vals['session'])) {
        $this->session = $vals['session'];
      }
      if (isset($vals['data_size'])) {
        $this->data_size = $vals['data_size'];
      }
    }
  }

  public function getName() {
    return 'BeginDownloadResult';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->version);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->session);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->data_size);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BeginDownloadResult');
    if ($this->version !== null) {
      $xfer += $output->writeFieldBegin('version', TType::I64, 1);
      $xfer += $output->writeI64($this->version);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->session !== null) {
      $xfer += $output->writeFieldBegin('session', TType::STRING, 2);
      $xfer += $output->writeString($this->session);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->data_size !== null) {
      $xfer += $output->writeFieldBegin('data_size', TType::I64, 3);
      $xfer += $output->writeI64($this->data_size);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SupervisorInfo {
  static $_TSPEC;

  /**
   * @var int
   */
  public $time_secs = null;
  /**
   * @var string
   */
  public $hostname = null;
  /**
   * @var string
   */
  public $assignment_id = null;
  /**
   * @var int[]
   */
  public $used_ports = null;
  /**
   * @var int[]
   */
  public $meta = null;
  /**
   * @var array
   */
  public $scheduler_meta = null;
  /**
   * @var int
   */
  public $uptime_secs = null;
  /**
   * @var string
   */
  public $version = null;
  /**
   * @var array
   */
  public $resources_map = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'time_secs',
          'type' => TType::I64,
          ),
        2 => array(
          'var' => 'hostname',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'assignment_id',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'used_ports',
          'type' => TType::LST,
          'etype' => TType::I64,
          'elem' => array(
            'type' => TType::I64,
            ),
          ),
        5 => array(
          'var' => 'meta',
          'type' => TType::LST,
          'etype' => TType::I64,
          'elem' => array(
            'type' => TType::I64,
            ),
          ),
        6 => array(
          'var' => 'scheduler_meta',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        7 => array(
          'var' => 'uptime_secs',
          'type' => TType::I64,
          ),
        8 => array(
          'var' => 'version',
          'type' => TType::STRING,
          ),
        9 => array(
          'var' => 'resources_map',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::DOUBLE,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::DOUBLE,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['time_secs'])) {
        $this->time_secs = $vals['time_secs'];
      }
      if (isset($vals['hostname'])) {
        $this->hostname = $vals['hostname'];
      }
      if (isset($vals['assignment_id'])) {
        $this->assignment_id = $vals['assignment_id'];
      }
      if (isset($vals['used_ports'])) {
        $this->used_ports = $vals['used_ports'];
      }
      if (isset($vals['meta'])) {
        $this->meta = $vals['meta'];
      }
      if (isset($vals['scheduler_meta'])) {
        $this->scheduler_meta = $vals['scheduler_meta'];
      }
      if (isset($vals['uptime_secs'])) {
        $this->uptime_secs = $vals['uptime_secs'];
      }
      if (isset($vals['version'])) {
        $this->version = $vals['version'];
      }
      if (isset($vals['resources_map'])) {
        $this->resources_map = $vals['resources_map'];
      }
    }
  }

  public function getName() {
    return 'SupervisorInfo';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->time_secs);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->hostname);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->assignment_id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::LST) {
            $this->used_ports = array();
            $_size513 = 0;
            $_etype516 = 0;
            $xfer += $input->readListBegin($_etype516, $_size513);
            for ($_i517 = 0; $_i517 < $_size513; ++$_i517)
            {
              $elem518 = null;
              $xfer += $input->readI64($elem518);
              $this->used_ports []= $elem518;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::LST) {
            $this->meta = array();
            $_size519 = 0;
            $_etype522 = 0;
            $xfer += $input->readListBegin($_etype522, $_size519);
            for ($_i523 = 0; $_i523 < $_size519; ++$_i523)
            {
              $elem524 = null;
              $xfer += $input->readI64($elem524);
              $this->meta []= $elem524;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::MAP) {
            $this->scheduler_meta = array();
            $_size525 = 0;
            $_ktype526 = 0;
            $_vtype527 = 0;
            $xfer += $input->readMapBegin($_ktype526, $_vtype527, $_size525);
            for ($_i529 = 0; $_i529 < $_size525; ++$_i529)
            {
              $key530 = '';
              $val531 = '';
              $xfer += $input->readString($key530);
              $xfer += $input->readString($val531);
              $this->scheduler_meta[$key530] = $val531;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->uptime_secs);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->version);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::MAP) {
            $this->resources_map = array();
            $_size532 = 0;
            $_ktype533 = 0;
            $_vtype534 = 0;
            $xfer += $input->readMapBegin($_ktype533, $_vtype534, $_size532);
            for ($_i536 = 0; $_i536 < $_size532; ++$_i536)
            {
              $key537 = '';
              $val538 = 0.0;
              $xfer += $input->readString($key537);
              $xfer += $input->readDouble($val538);
              $this->resources_map[$key537] = $val538;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SupervisorInfo');
    if ($this->time_secs !== null) {
      $xfer += $output->writeFieldBegin('time_secs', TType::I64, 1);
      $xfer += $output->writeI64($this->time_secs);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->hostname !== null) {
      $xfer += $output->writeFieldBegin('hostname', TType::STRING, 2);
      $xfer += $output->writeString($this->hostname);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->assignment_id !== null) {
      $xfer += $output->writeFieldBegin('assignment_id', TType::STRING, 3);
      $xfer += $output->writeString($this->assignment_id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->used_ports !== null) {
      if (!is_array($this->used_ports)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('used_ports', TType::LST, 4);
      {
        $output->writeListBegin(TType::I64, count($this->used_ports));
        {
          foreach ($this->used_ports as $iter539)
          {
            $xfer += $output->writeI64($iter539);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->meta !== null) {
      if (!is_array($this->meta)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('meta', TType::LST, 5);
      {
        $output->writeListBegin(TType::I64, count($this->meta));
        {
          foreach ($this->meta as $iter540)
          {
            $xfer += $output->writeI64($iter540);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->scheduler_meta !== null) {
      if (!is_array($this->scheduler_meta)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('scheduler_meta', TType::MAP, 6);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->scheduler_meta));
        {
          foreach ($this->scheduler_meta as $kiter541 => $viter542)
          {
            $xfer += $output->writeString($kiter541);
            $xfer += $output->writeString($viter542);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->uptime_secs !== null) {
      $xfer += $output->writeFieldBegin('uptime_secs', TType::I64, 7);
      $xfer += $output->writeI64($this->uptime_secs);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->version !== null) {
      $xfer += $output->writeFieldBegin('version', TType::STRING, 8);
      $xfer += $output->writeString($this->version);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->resources_map !== null) {
      if (!is_array($this->resources_map)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('resources_map', TType::MAP, 9);
      {
        $output->writeMapBegin(TType::STRING, TType::DOUBLE, count($this->resources_map));
        {
          foreach ($this->resources_map as $kiter543 => $viter544)
          {
            $xfer += $output->writeString($kiter543);
            $xfer += $output->writeDouble($viter544);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class NodeInfo {
  static $_TSPEC;

  /**
   * @var string
   */
  public $node = null;
  /**
   * @var int[]
   */
  public $port = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'node',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'port',
          'type' => TType::SET,
          'etype' => TType::I64,
          'elem' => array(
            'type' => TType::I64,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['node'])) {
        $this->node = $vals['node'];
      }
      if (isset($vals['port'])) {
        $this->port = $vals['port'];
      }
    }
  }

  public function getName() {
    return 'NodeInfo';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->node);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::SET) {
            $this->port = array();
            $_size545 = 0;
            $_etype548 = 0;
            $xfer += $input->readSetBegin($_etype548, $_size545);
            for ($_i549 = 0; $_i549 < $_size545; ++$_i549)
            {
              $elem550 = null;
              $xfer += $input->readI64($elem550);
              if (is_scalar($elem550)) {
                $this->port[$elem550] = true;
              } else {
                $this->port []= $elem550;
              }
            }
            $xfer += $input->readSetEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('NodeInfo');
    if ($this->node !== null) {
      $xfer += $output->writeFieldBegin('node', TType::STRING, 1);
      $xfer += $output->writeString($this->node);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->port !== null) {
      if (!is_array($this->port)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('port', TType::SET, 2);
      {
        $output->writeSetBegin(TType::I64, count($this->port));
        {
          foreach ($this->port as $iter551 => $iter552)
          {
            if (is_scalar($iter552)) {
            $xfer += $output->writeI64($iter551);
            } else {
            $xfer += $output->writeI64($iter552);
            }
          }
        }
        $output->writeSetEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class WorkerResources {
  static $_TSPEC;

  /**
   * @var double
   */
  public $mem_on_heap = null;
  /**
   * @var double
   */
  public $mem_off_heap = null;
  /**
   * @var double
   */
  public $cpu = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'mem_on_heap',
          'type' => TType::DOUBLE,
          ),
        2 => array(
          'var' => 'mem_off_heap',
          'type' => TType::DOUBLE,
          ),
        3 => array(
          'var' => 'cpu',
          'type' => TType::DOUBLE,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['mem_on_heap'])) {
        $this->mem_on_heap = $vals['mem_on_heap'];
      }
      if (isset($vals['mem_off_heap'])) {
        $this->mem_off_heap = $vals['mem_off_heap'];
      }
      if (isset($vals['cpu'])) {
        $this->cpu = $vals['cpu'];
      }
    }
  }

  public function getName() {
    return 'WorkerResources';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->mem_on_heap);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->mem_off_heap);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->cpu);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WorkerResources');
    if ($this->mem_on_heap !== null) {
      $xfer += $output->writeFieldBegin('mem_on_heap', TType::DOUBLE, 1);
      $xfer += $output->writeDouble($this->mem_on_heap);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->mem_off_heap !== null) {
      $xfer += $output->writeFieldBegin('mem_off_heap', TType::DOUBLE, 2);
      $xfer += $output->writeDouble($this->mem_off_heap);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->cpu !== null) {
      $xfer += $output->writeFieldBegin('cpu', TType::DOUBLE, 3);
      $xfer += $output->writeDouble($this->cpu);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Assignment {
  static $_TSPEC;

  /**
   * @var string
   */
  public $master_code_dir = null;
  /**
   * @var array
   */
  public $node_host = array(
  );
  /**
   * @var array
   */
  public $executor_node_port = array(
  );
  /**
   * @var array
   */
  public $executor_start_time_secs = array(
  );
  /**
   * @var array
   */
  public $worker_resources = array(
  );

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'master_code_dir',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'node_host',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        3 => array(
          'var' => 'executor_node_port',
          'type' => TType::MAP,
          'ktype' => TType::LST,
          'vtype' => TType::STRUCT,
          'key' => array(
            'type' => TType::LST,
            'etype' => TType::I64,
            'elem' => array(
              'type' => TType::I64,
              ),
          ),
          'val' => array(
            'type' => TType::STRUCT,
            'class' => '\topology\NodeInfo',
            ),
          ),
        4 => array(
          'var' => 'executor_start_time_secs',
          'type' => TType::MAP,
          'ktype' => TType::LST,
          'vtype' => TType::I64,
          'key' => array(
            'type' => TType::LST,
            'etype' => TType::I64,
            'elem' => array(
              'type' => TType::I64,
              ),
          ),
          'val' => array(
            'type' => TType::I64,
            ),
          ),
        5 => array(
          'var' => 'worker_resources',
          'type' => TType::MAP,
          'ktype' => TType::STRUCT,
          'vtype' => TType::STRUCT,
          'key' => array(
            'type' => TType::STRUCT,
            'class' => '\topology\NodeInfo',
          ),
          'val' => array(
            'type' => TType::STRUCT,
            'class' => '\topology\WorkerResources',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['master_code_dir'])) {
        $this->master_code_dir = $vals['master_code_dir'];
      }
      if (isset($vals['node_host'])) {
        $this->node_host = $vals['node_host'];
      }
      if (isset($vals['executor_node_port'])) {
        $this->executor_node_port = $vals['executor_node_port'];
      }
      if (isset($vals['executor_start_time_secs'])) {
        $this->executor_start_time_secs = $vals['executor_start_time_secs'];
      }
      if (isset($vals['worker_resources'])) {
        $this->worker_resources = $vals['worker_resources'];
      }
    }
  }

  public function getName() {
    return 'Assignment';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->master_code_dir);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::MAP) {
            $this->node_host = array();
            $_size553 = 0;
            $_ktype554 = 0;
            $_vtype555 = 0;
            $xfer += $input->readMapBegin($_ktype554, $_vtype555, $_size553);
            for ($_i557 = 0; $_i557 < $_size553; ++$_i557)
            {
              $key558 = '';
              $val559 = '';
              $xfer += $input->readString($key558);
              $xfer += $input->readString($val559);
              $this->node_host[$key558] = $val559;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::MAP) {
            $this->executor_node_port = array();
            $_size560 = 0;
            $_ktype561 = 0;
            $_vtype562 = 0;
            $xfer += $input->readMapBegin($_ktype561, $_vtype562, $_size560);
            for ($_i564 = 0; $_i564 < $_size560; ++$_i564)
            {
              $key565 = array();
              $val566 = new \topology\NodeInfo();
              $key565 = array();
              $_size567 = 0;
              $_etype570 = 0;
              $xfer += $input->readListBegin($_etype570, $_size567);
              for ($_i571 = 0; $_i571 < $_size567; ++$_i571)
              {
                $elem572 = null;
                $xfer += $input->readI64($elem572);
                $key565 []= $elem572;
              }
              $xfer += $input->readListEnd();
              $val566 = new \topology\NodeInfo();
              $xfer += $val566->read($input);
              $this->executor_node_port[$key565] = $val566;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::MAP) {
            $this->executor_start_time_secs = array();
            $_size573 = 0;
            $_ktype574 = 0;
            $_vtype575 = 0;
            $xfer += $input->readMapBegin($_ktype574, $_vtype575, $_size573);
            for ($_i577 = 0; $_i577 < $_size573; ++$_i577)
            {
              $key578 = array();
              $val579 = 0;
              $key578 = array();
              $_size580 = 0;
              $_etype583 = 0;
              $xfer += $input->readListBegin($_etype583, $_size580);
              for ($_i584 = 0; $_i584 < $_size580; ++$_i584)
              {
                $elem585 = null;
                $xfer += $input->readI64($elem585);
                $key578 []= $elem585;
              }
              $xfer += $input->readListEnd();
              $xfer += $input->readI64($val579);
              $this->executor_start_time_secs[$key578] = $val579;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::MAP) {
            $this->worker_resources = array();
            $_size586 = 0;
            $_ktype587 = 0;
            $_vtype588 = 0;
            $xfer += $input->readMapBegin($_ktype587, $_vtype588, $_size586);
            for ($_i590 = 0; $_i590 < $_size586; ++$_i590)
            {
              $key591 = new \topology\NodeInfo();
              $val592 = new \topology\WorkerResources();
              $key591 = new \topology\NodeInfo();
              $xfer += $key591->read($input);
              $val592 = new \topology\WorkerResources();
              $xfer += $val592->read($input);
              $this->worker_resources[$key591] = $val592;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Assignment');
    if ($this->master_code_dir !== null) {
      $xfer += $output->writeFieldBegin('master_code_dir', TType::STRING, 1);
      $xfer += $output->writeString($this->master_code_dir);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->node_host !== null) {
      if (!is_array($this->node_host)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('node_host', TType::MAP, 2);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->node_host));
        {
          foreach ($this->node_host as $kiter593 => $viter594)
          {
            $xfer += $output->writeString($kiter593);
            $xfer += $output->writeString($viter594);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->executor_node_port !== null) {
      if (!is_array($this->executor_node_port)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('executor_node_port', TType::MAP, 3);
      {
        $output->writeMapBegin(TType::LST, TType::STRUCT, count($this->executor_node_port));
        {
          foreach ($this->executor_node_port as $kiter595 => $viter596)
          {
            {
              $output->writeListBegin(TType::I64, count($kiter595));
              {
                foreach ($kiter595 as $iter597)
                {
                  $xfer += $output->writeI64($iter597);
                }
              }
              $output->writeListEnd();
            }
            $xfer += $viter596->write($output);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->executor_start_time_secs !== null) {
      if (!is_array($this->executor_start_time_secs)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('executor_start_time_secs', TType::MAP, 4);
      {
        $output->writeMapBegin(TType::LST, TType::I64, count($this->executor_start_time_secs));
        {
          foreach ($this->executor_start_time_secs as $kiter598 => $viter599)
          {
            {
              $output->writeListBegin(TType::I64, count($kiter598));
              {
                foreach ($kiter598 as $iter600)
                {
                  $xfer += $output->writeI64($iter600);
                }
              }
              $output->writeListEnd();
            }
            $xfer += $output->writeI64($viter599);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->worker_resources !== null) {
      if (!is_array($this->worker_resources)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('worker_resources', TType::MAP, 5);
      {
        $output->writeMapBegin(TType::STRUCT, TType::STRUCT, count($this->worker_resources));
        {
          foreach ($this->worker_resources as $kiter601 => $viter602)
          {
            $xfer += $kiter601->write($output);
            $xfer += $viter602->write($output);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TopologyActionOptions {
  static $_TSPEC;

  /**
   * @var \topology\KillOptions
   */
  public $kill_options = null;
  /**
   * @var \topology\RebalanceOptions
   */
  public $rebalance_options = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'kill_options',
          'type' => TType::STRUCT,
          'class' => '\topology\KillOptions',
          ),
        2 => array(
          'var' => 'rebalance_options',
          'type' => TType::STRUCT,
          'class' => '\topology\RebalanceOptions',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['kill_options'])) {
        $this->kill_options = $vals['kill_options'];
      }
      if (isset($vals['rebalance_options'])) {
        $this->rebalance_options = $vals['rebalance_options'];
      }
    }
  }

  public function getName() {
    return 'TopologyActionOptions';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->kill_options = new \topology\KillOptions();
            $xfer += $this->kill_options->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->rebalance_options = new \topology\RebalanceOptions();
            $xfer += $this->rebalance_options->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TopologyActionOptions');
    if ($this->kill_options !== null) {
      if (!is_object($this->kill_options)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('kill_options', TType::STRUCT, 1);
      $xfer += $this->kill_options->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->rebalance_options !== null) {
      if (!is_object($this->rebalance_options)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('rebalance_options', TType::STRUCT, 2);
      $xfer += $this->rebalance_options->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class StormBase {
  static $_TSPEC;

  /**
   * @var string
   */
  public $name = null;
  /**
   * @var int
   */
  public $status = null;
  /**
   * @var int
   */
  public $num_workers = null;
  /**
   * @var array
   */
  public $component_executors = null;
  /**
   * @var int
   */
  public $launch_time_secs = null;
  /**
   * @var string
   */
  public $owner = null;
  /**
   * @var \topology\TopologyActionOptions
   */
  public $topology_action_options = null;
  /**
   * @var int
   */
  public $prev_status = null;
  /**
   * @var array
   */
  public $component_debug = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'status',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'num_workers',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'component_executors',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::I32,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::I32,
            ),
          ),
        5 => array(
          'var' => 'launch_time_secs',
          'type' => TType::I32,
          ),
        6 => array(
          'var' => 'owner',
          'type' => TType::STRING,
          ),
        7 => array(
          'var' => 'topology_action_options',
          'type' => TType::STRUCT,
          'class' => '\topology\TopologyActionOptions',
          ),
        8 => array(
          'var' => 'prev_status',
          'type' => TType::I32,
          ),
        9 => array(
          'var' => 'component_debug',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRUCT,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRUCT,
            'class' => '\topology\DebugOptions',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
      if (isset($vals['num_workers'])) {
        $this->num_workers = $vals['num_workers'];
      }
      if (isset($vals['component_executors'])) {
        $this->component_executors = $vals['component_executors'];
      }
      if (isset($vals['launch_time_secs'])) {
        $this->launch_time_secs = $vals['launch_time_secs'];
      }
      if (isset($vals['owner'])) {
        $this->owner = $vals['owner'];
      }
      if (isset($vals['topology_action_options'])) {
        $this->topology_action_options = $vals['topology_action_options'];
      }
      if (isset($vals['prev_status'])) {
        $this->prev_status = $vals['prev_status'];
      }
      if (isset($vals['component_debug'])) {
        $this->component_debug = $vals['component_debug'];
      }
    }
  }

  public function getName() {
    return 'StormBase';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->status);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->num_workers);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::MAP) {
            $this->component_executors = array();
            $_size603 = 0;
            $_ktype604 = 0;
            $_vtype605 = 0;
            $xfer += $input->readMapBegin($_ktype604, $_vtype605, $_size603);
            for ($_i607 = 0; $_i607 < $_size603; ++$_i607)
            {
              $key608 = '';
              $val609 = 0;
              $xfer += $input->readString($key608);
              $xfer += $input->readI32($val609);
              $this->component_executors[$key608] = $val609;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->launch_time_secs);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->owner);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRUCT) {
            $this->topology_action_options = new \topology\TopologyActionOptions();
            $xfer += $this->topology_action_options->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->prev_status);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::MAP) {
            $this->component_debug = array();
            $_size610 = 0;
            $_ktype611 = 0;
            $_vtype612 = 0;
            $xfer += $input->readMapBegin($_ktype611, $_vtype612, $_size610);
            for ($_i614 = 0; $_i614 < $_size610; ++$_i614)
            {
              $key615 = '';
              $val616 = new \topology\DebugOptions();
              $xfer += $input->readString($key615);
              $val616 = new \topology\DebugOptions();
              $xfer += $val616->read($input);
              $this->component_debug[$key615] = $val616;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('StormBase');
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->status !== null) {
      $xfer += $output->writeFieldBegin('status', TType::I32, 2);
      $xfer += $output->writeI32($this->status);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->num_workers !== null) {
      $xfer += $output->writeFieldBegin('num_workers', TType::I32, 3);
      $xfer += $output->writeI32($this->num_workers);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->component_executors !== null) {
      if (!is_array($this->component_executors)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('component_executors', TType::MAP, 4);
      {
        $output->writeMapBegin(TType::STRING, TType::I32, count($this->component_executors));
        {
          foreach ($this->component_executors as $kiter617 => $viter618)
          {
            $xfer += $output->writeString($kiter617);
            $xfer += $output->writeI32($viter618);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->launch_time_secs !== null) {
      $xfer += $output->writeFieldBegin('launch_time_secs', TType::I32, 5);
      $xfer += $output->writeI32($this->launch_time_secs);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->owner !== null) {
      $xfer += $output->writeFieldBegin('owner', TType::STRING, 6);
      $xfer += $output->writeString($this->owner);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->topology_action_options !== null) {
      if (!is_object($this->topology_action_options)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('topology_action_options', TType::STRUCT, 7);
      $xfer += $this->topology_action_options->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->prev_status !== null) {
      $xfer += $output->writeFieldBegin('prev_status', TType::I32, 8);
      $xfer += $output->writeI32($this->prev_status);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->component_debug !== null) {
      if (!is_array($this->component_debug)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('component_debug', TType::MAP, 9);
      {
        $output->writeMapBegin(TType::STRING, TType::STRUCT, count($this->component_debug));
        {
          foreach ($this->component_debug as $kiter619 => $viter620)
          {
            $xfer += $output->writeString($kiter619);
            $xfer += $viter620->write($output);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ClusterWorkerHeartbeat {
  static $_TSPEC;

  /**
   * @var string
   */
  public $storm_id = null;
  /**
   * @var array
   */
  public $executor_stats = null;
  /**
   * @var int
   */
  public $time_secs = null;
  /**
   * @var int
   */
  public $uptime_secs = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'storm_id',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'executor_stats',
          'type' => TType::MAP,
          'ktype' => TType::STRUCT,
          'vtype' => TType::STRUCT,
          'key' => array(
            'type' => TType::STRUCT,
            'class' => '\topology\ExecutorInfo',
          ),
          'val' => array(
            'type' => TType::STRUCT,
            'class' => '\topology\ExecutorStats',
            ),
          ),
        3 => array(
          'var' => 'time_secs',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'uptime_secs',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['storm_id'])) {
        $this->storm_id = $vals['storm_id'];
      }
      if (isset($vals['executor_stats'])) {
        $this->executor_stats = $vals['executor_stats'];
      }
      if (isset($vals['time_secs'])) {
        $this->time_secs = $vals['time_secs'];
      }
      if (isset($vals['uptime_secs'])) {
        $this->uptime_secs = $vals['uptime_secs'];
      }
    }
  }

  public function getName() {
    return 'ClusterWorkerHeartbeat';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->storm_id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::MAP) {
            $this->executor_stats = array();
            $_size621 = 0;
            $_ktype622 = 0;
            $_vtype623 = 0;
            $xfer += $input->readMapBegin($_ktype622, $_vtype623, $_size621);
            for ($_i625 = 0; $_i625 < $_size621; ++$_i625)
            {
              $key626 = new \topology\ExecutorInfo();
              $val627 = new \topology\ExecutorStats();
              $key626 = new \topology\ExecutorInfo();
              $xfer += $key626->read($input);
              $val627 = new \topology\ExecutorStats();
              $xfer += $val627->read($input);
              $this->executor_stats[$key626] = $val627;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->time_secs);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->uptime_secs);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ClusterWorkerHeartbeat');
    if ($this->storm_id !== null) {
      $xfer += $output->writeFieldBegin('storm_id', TType::STRING, 1);
      $xfer += $output->writeString($this->storm_id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->executor_stats !== null) {
      if (!is_array($this->executor_stats)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('executor_stats', TType::MAP, 2);
      {
        $output->writeMapBegin(TType::STRUCT, TType::STRUCT, count($this->executor_stats));
        {
          foreach ($this->executor_stats as $kiter628 => $viter629)
          {
            $xfer += $kiter628->write($output);
            $xfer += $viter629->write($output);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->time_secs !== null) {
      $xfer += $output->writeFieldBegin('time_secs', TType::I32, 3);
      $xfer += $output->writeI32($this->time_secs);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->uptime_secs !== null) {
      $xfer += $output->writeFieldBegin('uptime_secs', TType::I32, 4);
      $xfer += $output->writeI32($this->uptime_secs);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ThriftSerializedObject {
  static $_TSPEC;

  /**
   * @var string
   */
  public $name = null;
  /**
   * @var string
   */
  public $bits = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'bits',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['bits'])) {
        $this->bits = $vals['bits'];
      }
    }
  }

  public function getName() {
    return 'ThriftSerializedObject';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->bits);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ThriftSerializedObject');
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->bits !== null) {
      $xfer += $output->writeFieldBegin('bits', TType::STRING, 2);
      $xfer += $output->writeString($this->bits);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class LocalStateData {
  static $_TSPEC;

  /**
   * @var array
   */
  public $serialized_parts = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'serialized_parts',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRUCT,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRUCT,
            'class' => '\topology\ThriftSerializedObject',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['serialized_parts'])) {
        $this->serialized_parts = $vals['serialized_parts'];
      }
    }
  }

  public function getName() {
    return 'LocalStateData';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->serialized_parts = array();
            $_size630 = 0;
            $_ktype631 = 0;
            $_vtype632 = 0;
            $xfer += $input->readMapBegin($_ktype631, $_vtype632, $_size630);
            for ($_i634 = 0; $_i634 < $_size630; ++$_i634)
            {
              $key635 = '';
              $val636 = new \topology\ThriftSerializedObject();
              $xfer += $input->readString($key635);
              $val636 = new \topology\ThriftSerializedObject();
              $xfer += $val636->read($input);
              $this->serialized_parts[$key635] = $val636;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('LocalStateData');
    if ($this->serialized_parts !== null) {
      if (!is_array($this->serialized_parts)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('serialized_parts', TType::MAP, 1);
      {
        $output->writeMapBegin(TType::STRING, TType::STRUCT, count($this->serialized_parts));
        {
          foreach ($this->serialized_parts as $kiter637 => $viter638)
          {
            $xfer += $output->writeString($kiter637);
            $xfer += $viter638->write($output);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class LocalAssignment {
  static $_TSPEC;

  /**
   * @var string
   */
  public $topology_id = null;
  /**
   * @var \topology\ExecutorInfo[]
   */
  public $executors = null;
  /**
   * @var \topology\WorkerResources
   */
  public $resources = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'topology_id',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'executors',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\topology\ExecutorInfo',
            ),
          ),
        3 => array(
          'var' => 'resources',
          'type' => TType::STRUCT,
          'class' => '\topology\WorkerResources',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['topology_id'])) {
        $this->topology_id = $vals['topology_id'];
      }
      if (isset($vals['executors'])) {
        $this->executors = $vals['executors'];
      }
      if (isset($vals['resources'])) {
        $this->resources = $vals['resources'];
      }
    }
  }

  public function getName() {
    return 'LocalAssignment';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->topology_id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->executors = array();
            $_size639 = 0;
            $_etype642 = 0;
            $xfer += $input->readListBegin($_etype642, $_size639);
            for ($_i643 = 0; $_i643 < $_size639; ++$_i643)
            {
              $elem644 = null;
              $elem644 = new \topology\ExecutorInfo();
              $xfer += $elem644->read($input);
              $this->executors []= $elem644;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->resources = new \topology\WorkerResources();
            $xfer += $this->resources->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('LocalAssignment');
    if ($this->topology_id !== null) {
      $xfer += $output->writeFieldBegin('topology_id', TType::STRING, 1);
      $xfer += $output->writeString($this->topology_id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->executors !== null) {
      if (!is_array($this->executors)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('executors', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->executors));
        {
          foreach ($this->executors as $iter645)
          {
            $xfer += $iter645->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->resources !== null) {
      if (!is_object($this->resources)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('resources', TType::STRUCT, 3);
      $xfer += $this->resources->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class LSSupervisorId {
  static $_TSPEC;

  /**
   * @var string
   */
  public $supervisor_id = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'supervisor_id',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['supervisor_id'])) {
        $this->supervisor_id = $vals['supervisor_id'];
      }
    }
  }

  public function getName() {
    return 'LSSupervisorId';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->supervisor_id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('LSSupervisorId');
    if ($this->supervisor_id !== null) {
      $xfer += $output->writeFieldBegin('supervisor_id', TType::STRING, 1);
      $xfer += $output->writeString($this->supervisor_id);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class LSApprovedWorkers {
  static $_TSPEC;

  /**
   * @var array
   */
  public $approved_workers = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'approved_workers',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::I32,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::I32,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['approved_workers'])) {
        $this->approved_workers = $vals['approved_workers'];
      }
    }
  }

  public function getName() {
    return 'LSApprovedWorkers';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->approved_workers = array();
            $_size646 = 0;
            $_ktype647 = 0;
            $_vtype648 = 0;
            $xfer += $input->readMapBegin($_ktype647, $_vtype648, $_size646);
            for ($_i650 = 0; $_i650 < $_size646; ++$_i650)
            {
              $key651 = '';
              $val652 = 0;
              $xfer += $input->readString($key651);
              $xfer += $input->readI32($val652);
              $this->approved_workers[$key651] = $val652;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('LSApprovedWorkers');
    if ($this->approved_workers !== null) {
      if (!is_array($this->approved_workers)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('approved_workers', TType::MAP, 1);
      {
        $output->writeMapBegin(TType::STRING, TType::I32, count($this->approved_workers));
        {
          foreach ($this->approved_workers as $kiter653 => $viter654)
          {
            $xfer += $output->writeString($kiter653);
            $xfer += $output->writeI32($viter654);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class LSSupervisorAssignments {
  static $_TSPEC;

  /**
   * @var array
   */
  public $assignments = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'assignments',
          'type' => TType::MAP,
          'ktype' => TType::I32,
          'vtype' => TType::STRUCT,
          'key' => array(
            'type' => TType::I32,
          ),
          'val' => array(
            'type' => TType::STRUCT,
            'class' => '\topology\LocalAssignment',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['assignments'])) {
        $this->assignments = $vals['assignments'];
      }
    }
  }

  public function getName() {
    return 'LSSupervisorAssignments';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->assignments = array();
            $_size655 = 0;
            $_ktype656 = 0;
            $_vtype657 = 0;
            $xfer += $input->readMapBegin($_ktype656, $_vtype657, $_size655);
            for ($_i659 = 0; $_i659 < $_size655; ++$_i659)
            {
              $key660 = 0;
              $val661 = new \topology\LocalAssignment();
              $xfer += $input->readI32($key660);
              $val661 = new \topology\LocalAssignment();
              $xfer += $val661->read($input);
              $this->assignments[$key660] = $val661;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('LSSupervisorAssignments');
    if ($this->assignments !== null) {
      if (!is_array($this->assignments)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('assignments', TType::MAP, 1);
      {
        $output->writeMapBegin(TType::I32, TType::STRUCT, count($this->assignments));
        {
          foreach ($this->assignments as $kiter662 => $viter663)
          {
            $xfer += $output->writeI32($kiter662);
            $xfer += $viter663->write($output);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class LSWorkerHeartbeat {
  static $_TSPEC;

  /**
   * @var int
   */
  public $time_secs = null;
  /**
   * @var string
   */
  public $topology_id = null;
  /**
   * @var \topology\ExecutorInfo[]
   */
  public $executors = null;
  /**
   * @var int
   */
  public $port = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'time_secs',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'topology_id',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'executors',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\topology\ExecutorInfo',
            ),
          ),
        4 => array(
          'var' => 'port',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['time_secs'])) {
        $this->time_secs = $vals['time_secs'];
      }
      if (isset($vals['topology_id'])) {
        $this->topology_id = $vals['topology_id'];
      }
      if (isset($vals['executors'])) {
        $this->executors = $vals['executors'];
      }
      if (isset($vals['port'])) {
        $this->port = $vals['port'];
      }
    }
  }

  public function getName() {
    return 'LSWorkerHeartbeat';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->time_secs);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->topology_id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->executors = array();
            $_size664 = 0;
            $_etype667 = 0;
            $xfer += $input->readListBegin($_etype667, $_size664);
            for ($_i668 = 0; $_i668 < $_size664; ++$_i668)
            {
              $elem669 = null;
              $elem669 = new \topology\ExecutorInfo();
              $xfer += $elem669->read($input);
              $this->executors []= $elem669;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->port);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('LSWorkerHeartbeat');
    if ($this->time_secs !== null) {
      $xfer += $output->writeFieldBegin('time_secs', TType::I32, 1);
      $xfer += $output->writeI32($this->time_secs);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->topology_id !== null) {
      $xfer += $output->writeFieldBegin('topology_id', TType::STRING, 2);
      $xfer += $output->writeString($this->topology_id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->executors !== null) {
      if (!is_array($this->executors)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('executors', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRUCT, count($this->executors));
        {
          foreach ($this->executors as $iter670)
          {
            $xfer += $iter670->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->port !== null) {
      $xfer += $output->writeFieldBegin('port', TType::I32, 4);
      $xfer += $output->writeI32($this->port);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class LSTopoHistory {
  static $_TSPEC;

  /**
   * @var string
   */
  public $topology_id = null;
  /**
   * @var int
   */
  public $time_stamp = null;
  /**
   * @var string[]
   */
  public $users = null;
  /**
   * @var string[]
   */
  public $groups = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'topology_id',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'time_stamp',
          'type' => TType::I64,
          ),
        3 => array(
          'var' => 'users',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        4 => array(
          'var' => 'groups',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['topology_id'])) {
        $this->topology_id = $vals['topology_id'];
      }
      if (isset($vals['time_stamp'])) {
        $this->time_stamp = $vals['time_stamp'];
      }
      if (isset($vals['users'])) {
        $this->users = $vals['users'];
      }
      if (isset($vals['groups'])) {
        $this->groups = $vals['groups'];
      }
    }
  }

  public function getName() {
    return 'LSTopoHistory';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->topology_id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->time_stamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->users = array();
            $_size671 = 0;
            $_etype674 = 0;
            $xfer += $input->readListBegin($_etype674, $_size671);
            for ($_i675 = 0; $_i675 < $_size671; ++$_i675)
            {
              $elem676 = null;
              $xfer += $input->readString($elem676);
              $this->users []= $elem676;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::LST) {
            $this->groups = array();
            $_size677 = 0;
            $_etype680 = 0;
            $xfer += $input->readListBegin($_etype680, $_size677);
            for ($_i681 = 0; $_i681 < $_size677; ++$_i681)
            {
              $elem682 = null;
              $xfer += $input->readString($elem682);
              $this->groups []= $elem682;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('LSTopoHistory');
    if ($this->topology_id !== null) {
      $xfer += $output->writeFieldBegin('topology_id', TType::STRING, 1);
      $xfer += $output->writeString($this->topology_id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->time_stamp !== null) {
      $xfer += $output->writeFieldBegin('time_stamp', TType::I64, 2);
      $xfer += $output->writeI64($this->time_stamp);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->users !== null) {
      if (!is_array($this->users)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('users', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->users));
        {
          foreach ($this->users as $iter683)
          {
            $xfer += $output->writeString($iter683);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->groups !== null) {
      if (!is_array($this->groups)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('groups', TType::LST, 4);
      {
        $output->writeListBegin(TType::STRING, count($this->groups));
        {
          foreach ($this->groups as $iter684)
          {
            $xfer += $output->writeString($iter684);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class LSTopoHistoryList {
  static $_TSPEC;

  /**
   * @var \topology\LSTopoHistory[]
   */
  public $topo_history = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'topo_history',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\topology\LSTopoHistory',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['topo_history'])) {
        $this->topo_history = $vals['topo_history'];
      }
    }
  }

  public function getName() {
    return 'LSTopoHistoryList';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->topo_history = array();
            $_size685 = 0;
            $_etype688 = 0;
            $xfer += $input->readListBegin($_etype688, $_size685);
            for ($_i689 = 0; $_i689 < $_size685; ++$_i689)
            {
              $elem690 = null;
              $elem690 = new \topology\LSTopoHistory();
              $xfer += $elem690->read($input);
              $this->topo_history []= $elem690;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('LSTopoHistoryList');
    if ($this->topo_history !== null) {
      if (!is_array($this->topo_history)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('topo_history', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->topo_history));
        {
          foreach ($this->topo_history as $iter691)
          {
            $xfer += $iter691->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ProfileRequest {
  static $_TSPEC;

  /**
   * @var \topology\NodeInfo
   */
  public $nodeInfo = null;
  /**
   * @var int
   */
  public $action = null;
  /**
   * @var int
   */
  public $time_stamp = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'nodeInfo',
          'type' => TType::STRUCT,
          'class' => '\topology\NodeInfo',
          ),
        2 => array(
          'var' => 'action',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'time_stamp',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['nodeInfo'])) {
        $this->nodeInfo = $vals['nodeInfo'];
      }
      if (isset($vals['action'])) {
        $this->action = $vals['action'];
      }
      if (isset($vals['time_stamp'])) {
        $this->time_stamp = $vals['time_stamp'];
      }
    }
  }

  public function getName() {
    return 'ProfileRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->nodeInfo = new \topology\NodeInfo();
            $xfer += $this->nodeInfo->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->action);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->time_stamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ProfileRequest');
    if ($this->nodeInfo !== null) {
      if (!is_object($this->nodeInfo)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('nodeInfo', TType::STRUCT, 1);
      $xfer += $this->nodeInfo->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->action !== null) {
      $xfer += $output->writeFieldBegin('action', TType::I32, 2);
      $xfer += $output->writeI32($this->action);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->time_stamp !== null) {
      $xfer += $output->writeFieldBegin('time_stamp', TType::I64, 3);
      $xfer += $output->writeI64($this->time_stamp);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class GetInfoOptions {
  static $_TSPEC;

  /**
   * @var int
   */
  public $num_err_choice = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'num_err_choice',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['num_err_choice'])) {
        $this->num_err_choice = $vals['num_err_choice'];
      }
    }
  }

  public function getName() {
    return 'GetInfoOptions';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->num_err_choice);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('GetInfoOptions');
    if ($this->num_err_choice !== null) {
      $xfer += $output->writeFieldBegin('num_err_choice', TType::I32, 1);
      $xfer += $output->writeI32($this->num_err_choice);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class LogLevel {
  static $_TSPEC;

  /**
   * @var int
   */
  public $action = null;
  /**
   * @var string
   */
  public $target_log_level = null;
  /**
   * @var int
   */
  public $reset_log_level_timeout_secs = null;
  /**
   * @var int
   */
  public $reset_log_level_timeout_epoch = null;
  /**
   * @var string
   */
  public $reset_log_level = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'action',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'target_log_level',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'reset_log_level_timeout_secs',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'reset_log_level_timeout_epoch',
          'type' => TType::I64,
          ),
        5 => array(
          'var' => 'reset_log_level',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['action'])) {
        $this->action = $vals['action'];
      }
      if (isset($vals['target_log_level'])) {
        $this->target_log_level = $vals['target_log_level'];
      }
      if (isset($vals['reset_log_level_timeout_secs'])) {
        $this->reset_log_level_timeout_secs = $vals['reset_log_level_timeout_secs'];
      }
      if (isset($vals['reset_log_level_timeout_epoch'])) {
        $this->reset_log_level_timeout_epoch = $vals['reset_log_level_timeout_epoch'];
      }
      if (isset($vals['reset_log_level'])) {
        $this->reset_log_level = $vals['reset_log_level'];
      }
    }
  }

  public function getName() {
    return 'LogLevel';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->action);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->target_log_level);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->reset_log_level_timeout_secs);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->reset_log_level_timeout_epoch);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->reset_log_level);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('LogLevel');
    if ($this->action !== null) {
      $xfer += $output->writeFieldBegin('action', TType::I32, 1);
      $xfer += $output->writeI32($this->action);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->target_log_level !== null) {
      $xfer += $output->writeFieldBegin('target_log_level', TType::STRING, 2);
      $xfer += $output->writeString($this->target_log_level);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->reset_log_level_timeout_secs !== null) {
      $xfer += $output->writeFieldBegin('reset_log_level_timeout_secs', TType::I32, 3);
      $xfer += $output->writeI32($this->reset_log_level_timeout_secs);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->reset_log_level_timeout_epoch !== null) {
      $xfer += $output->writeFieldBegin('reset_log_level_timeout_epoch', TType::I64, 4);
      $xfer += $output->writeI64($this->reset_log_level_timeout_epoch);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->reset_log_level !== null) {
      $xfer += $output->writeFieldBegin('reset_log_level', TType::STRING, 5);
      $xfer += $output->writeString($this->reset_log_level);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class LogConfig {
  static $_TSPEC;

  /**
   * @var array
   */
  public $named_logger_level = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        2 => array(
          'var' => 'named_logger_level',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRUCT,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRUCT,
            'class' => '\topology\LogLevel',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['named_logger_level'])) {
        $this->named_logger_level = $vals['named_logger_level'];
      }
    }
  }

  public function getName() {
    return 'LogConfig';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 2:
          if ($ftype == TType::MAP) {
            $this->named_logger_level = array();
            $_size692 = 0;
            $_ktype693 = 0;
            $_vtype694 = 0;
            $xfer += $input->readMapBegin($_ktype693, $_vtype694, $_size692);
            for ($_i696 = 0; $_i696 < $_size692; ++$_i696)
            {
              $key697 = '';
              $val698 = new \topology\LogLevel();
              $xfer += $input->readString($key697);
              $val698 = new \topology\LogLevel();
              $xfer += $val698->read($input);
              $this->named_logger_level[$key697] = $val698;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('LogConfig');
    if ($this->named_logger_level !== null) {
      if (!is_array($this->named_logger_level)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('named_logger_level', TType::MAP, 2);
      {
        $output->writeMapBegin(TType::STRING, TType::STRUCT, count($this->named_logger_level));
        {
          foreach ($this->named_logger_level as $kiter699 => $viter700)
          {
            $xfer += $output->writeString($kiter699);
            $xfer += $viter700->write($output);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class TopologyHistoryInfo {
  static $_TSPEC;

  /**
   * @var string[]
   */
  public $topo_ids = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'topo_ids',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['topo_ids'])) {
        $this->topo_ids = $vals['topo_ids'];
      }
    }
  }

  public function getName() {
    return 'TopologyHistoryInfo';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->topo_ids = array();
            $_size701 = 0;
            $_etype704 = 0;
            $xfer += $input->readListBegin($_etype704, $_size701);
            for ($_i705 = 0; $_i705 < $_size701; ++$_i705)
            {
              $elem706 = null;
              $xfer += $input->readString($elem706);
              $this->topo_ids []= $elem706;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TopologyHistoryInfo');
    if ($this->topo_ids !== null) {
      if (!is_array($this->topo_ids)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('topo_ids', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRING, count($this->topo_ids));
        {
          foreach ($this->topo_ids as $iter707)
          {
            $xfer += $output->writeString($iter707);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class DRPCRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $func_args = null;
  /**
   * @var string
   */
  public $request_id = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'func_args',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'request_id',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['func_args'])) {
        $this->func_args = $vals['func_args'];
      }
      if (isset($vals['request_id'])) {
        $this->request_id = $vals['request_id'];
      }
    }
  }

  public function getName() {
    return 'DRPCRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->func_args);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->request_id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DRPCRequest');
    if ($this->func_args !== null) {
      $xfer += $output->writeFieldBegin('func_args', TType::STRING, 1);
      $xfer += $output->writeString($this->func_args);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->request_id !== null) {
      $xfer += $output->writeFieldBegin('request_id', TType::STRING, 2);
      $xfer += $output->writeString($this->request_id);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class DRPCExecutionException extends TException {
  static $_TSPEC;

  /**
   * @var string
   */
  public $msg = null;
  /**
   * @var int
   */
  public $type = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'msg',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'type',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['msg'])) {
        $this->msg = $vals['msg'];
      }
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
    }
  }

  public function getName() {
    return 'DRPCExecutionException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->msg);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DRPCExecutionException');
    if ($this->msg !== null) {
      $xfer += $output->writeFieldBegin('msg', TType::STRING, 1);
      $xfer += $output->writeString($this->msg);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->type !== null) {
      $xfer += $output->writeFieldBegin('type', TType::I32, 2);
      $xfer += $output->writeI32($this->type);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class HBPulse {
  static $_TSPEC;

  /**
   * @var string
   */
  public $id = null;
  /**
   * @var string
   */
  public $details = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'id',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'details',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['id'])) {
        $this->id = $vals['id'];
      }
      if (isset($vals['details'])) {
        $this->details = $vals['details'];
      }
    }
  }

  public function getName() {
    return 'HBPulse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->details);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('HBPulse');
    if ($this->id !== null) {
      $xfer += $output->writeFieldBegin('id', TType::STRING, 1);
      $xfer += $output->writeString($this->id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->details !== null) {
      $xfer += $output->writeFieldBegin('details', TType::STRING, 2);
      $xfer += $output->writeString($this->details);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class HBRecords {
  static $_TSPEC;

  /**
   * @var \topology\HBPulse[]
   */
  public $pulses = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'pulses',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\topology\HBPulse',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['pulses'])) {
        $this->pulses = $vals['pulses'];
      }
    }
  }

  public function getName() {
    return 'HBRecords';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->pulses = array();
            $_size708 = 0;
            $_etype711 = 0;
            $xfer += $input->readListBegin($_etype711, $_size708);
            for ($_i712 = 0; $_i712 < $_size708; ++$_i712)
            {
              $elem713 = null;
              $elem713 = new \topology\HBPulse();
              $xfer += $elem713->read($input);
              $this->pulses []= $elem713;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('HBRecords');
    if ($this->pulses !== null) {
      if (!is_array($this->pulses)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('pulses', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->pulses));
        {
          foreach ($this->pulses as $iter714)
          {
            $xfer += $iter714->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class HBNodes {
  static $_TSPEC;

  /**
   * @var string[]
   */
  public $pulseIds = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'pulseIds',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['pulseIds'])) {
        $this->pulseIds = $vals['pulseIds'];
      }
    }
  }

  public function getName() {
    return 'HBNodes';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->pulseIds = array();
            $_size715 = 0;
            $_etype718 = 0;
            $xfer += $input->readListBegin($_etype718, $_size715);
            for ($_i719 = 0; $_i719 < $_size715; ++$_i719)
            {
              $elem720 = null;
              $xfer += $input->readString($elem720);
              $this->pulseIds []= $elem720;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('HBNodes');
    if ($this->pulseIds !== null) {
      if (!is_array($this->pulseIds)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('pulseIds', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRING, count($this->pulseIds));
        {
          foreach ($this->pulseIds as $iter721)
          {
            $xfer += $output->writeString($iter721);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class HBMessageData {
  static $_TSPEC;

  /**
   * @var string
   */
  public $path = null;
  /**
   * @var \topology\HBPulse
   */
  public $pulse = null;
  /**
   * @var bool
   */
  public $boolval = null;
  /**
   * @var \topology\HBRecords
   */
  public $records = null;
  /**
   * @var \topology\HBNodes
   */
  public $nodes = null;
  /**
   * @var string
   */
  public $message_blob = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'path',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'pulse',
          'type' => TType::STRUCT,
          'class' => '\topology\HBPulse',
          ),
        3 => array(
          'var' => 'boolval',
          'type' => TType::BOOL,
          ),
        4 => array(
          'var' => 'records',
          'type' => TType::STRUCT,
          'class' => '\topology\HBRecords',
          ),
        5 => array(
          'var' => 'nodes',
          'type' => TType::STRUCT,
          'class' => '\topology\HBNodes',
          ),
        7 => array(
          'var' => 'message_blob',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['path'])) {
        $this->path = $vals['path'];
      }
      if (isset($vals['pulse'])) {
        $this->pulse = $vals['pulse'];
      }
      if (isset($vals['boolval'])) {
        $this->boolval = $vals['boolval'];
      }
      if (isset($vals['records'])) {
        $this->records = $vals['records'];
      }
      if (isset($vals['nodes'])) {
        $this->nodes = $vals['nodes'];
      }
      if (isset($vals['message_blob'])) {
        $this->message_blob = $vals['message_blob'];
      }
    }
  }

  public function getName() {
    return 'HBMessageData';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->path);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->pulse = new \topology\HBPulse();
            $xfer += $this->pulse->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->boolval);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->records = new \topology\HBRecords();
            $xfer += $this->records->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRUCT) {
            $this->nodes = new \topology\HBNodes();
            $xfer += $this->nodes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message_blob);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('HBMessageData');
    if ($this->path !== null) {
      $xfer += $output->writeFieldBegin('path', TType::STRING, 1);
      $xfer += $output->writeString($this->path);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->pulse !== null) {
      if (!is_object($this->pulse)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('pulse', TType::STRUCT, 2);
      $xfer += $this->pulse->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->boolval !== null) {
      $xfer += $output->writeFieldBegin('boolval', TType::BOOL, 3);
      $xfer += $output->writeBool($this->boolval);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->records !== null) {
      if (!is_object($this->records)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('records', TType::STRUCT, 4);
      $xfer += $this->records->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->nodes !== null) {
      if (!is_object($this->nodes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('nodes', TType::STRUCT, 5);
      $xfer += $this->nodes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->message_blob !== null) {
      $xfer += $output->writeFieldBegin('message_blob', TType::STRING, 7);
      $xfer += $output->writeString($this->message_blob);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class HBMessage {
  static $_TSPEC;

  /**
   * @var int
   */
  public $type = null;
  /**
   * @var \topology\HBMessageData
   */
  public $data = null;
  /**
   * @var int
   */
  public $message_id = -1;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'type',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'data',
          'type' => TType::STRUCT,
          'class' => '\topology\HBMessageData',
          ),
        3 => array(
          'var' => 'message_id',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
      if (isset($vals['data'])) {
        $this->data = $vals['data'];
      }
      if (isset($vals['message_id'])) {
        $this->message_id = $vals['message_id'];
      }
    }
  }

  public function getName() {
    return 'HBMessage';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->data = new \topology\HBMessageData();
            $xfer += $this->data->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->message_id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('HBMessage');
    if ($this->type !== null) {
      $xfer += $output->writeFieldBegin('type', TType::I32, 1);
      $xfer += $output->writeI32($this->type);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->data !== null) {
      if (!is_object($this->data)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('data', TType::STRUCT, 2);
      $xfer += $this->data->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->message_id !== null) {
      $xfer += $output->writeFieldBegin('message_id', TType::I32, 3);
      $xfer += $output->writeI32($this->message_id);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class HBAuthorizationException extends TException {
  static $_TSPEC;

  /**
   * @var string
   */
  public $msg = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'msg',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['msg'])) {
        $this->msg = $vals['msg'];
      }
    }
  }

  public function getName() {
    return 'HBAuthorizationException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->msg);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('HBAuthorizationException');
    if ($this->msg !== null) {
      $xfer += $output->writeFieldBegin('msg', TType::STRING, 1);
      $xfer += $output->writeString($this->msg);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class HBExecutionException extends TException {
  static $_TSPEC;

  /**
   * @var string
   */
  public $msg = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'msg',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['msg'])) {
        $this->msg = $vals['msg'];
      }
    }
  }

  public function getName() {
    return 'HBExecutionException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->msg);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('HBExecutionException');
    if ($this->msg !== null) {
      $xfer += $output->writeFieldBegin('msg', TType::STRING, 1);
      $xfer += $output->writeString($this->msg);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}


